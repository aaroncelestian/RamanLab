#!/usr/bin/env python3
"""
RamanLab Qt6 - Database Browser Window
Qt6 conversion of the database browser functionality
"""

import os
import numpy as np
import pandas as pd
from pathlib import Path
from datetime import datetime
import pickle
import time

# Matplotlib imports
import matplotlib
matplotlib.use("QtAgg")
from matplotlib.figure import Figure
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas
from polarization_ui.matplotlib_config import CompactNavigationToolbar as NavigationToolbar

# Qt6 imports
from PySide6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QTabWidget, QWidget, QLabel, QPushButton,
    QLineEdit, QListWidget, QTextEdit, QTreeWidget, QTreeWidgetItem, QSplitter,
    QGroupBox, QCheckBox, QComboBox, QSpinBox, QDoubleSpinBox, QProgressBar,
    QFileDialog, QMessageBox, QFormLayout, QGridLayout, QFrame, QListWidgetItem,
    QProgressDialog, QSizePolicy
)
from PySide6.QtCore import Qt, QStandardPaths, QTimer, QThread, Signal
from PySide6.QtGui import QFont
from PySide6.QtWidgets import QApplication

from scipy.signal import find_peaks

# Hey Classification System imports
try:
    from Hey_class.improved_hey_classification import ImprovedHeyClassifier, HEY_CATEGORIES
    from Hey_class.raman_vibrational_classifier import HeyCelestianClassifier
    from Hey_class.improved_element_extraction import extract_elements_from_formula
    HEY_CLASSIFICATION_AVAILABLE = True
except ImportError as e:
    print(f"Hey Classification system not available: {e}")
    HEY_CLASSIFICATION_AVAILABLE = False
    HEY_CATEGORIES = {}


class DatabaseBrowserQt6(QDialog):
    """Qt6 Database Browser Window for RamanLab."""
    
    def __init__(self, raman_db, parent=None):
        """
        Initialize the database browser.
        
        Parameters:
        -----------
        raman_db : RamanSpectraQt6
            Database instance
        parent : QWidget, optional
            Parent widget
        """
        super().__init__(parent)
        self.raman_db = raman_db
        self.current_spectrum = None
        self.current_peaks = None
        
        # Hey Index tab variables
        self.current_hey_spectrum = None
        
        # Hey Classification System variables
        self.hey_classifier = None
        self.hey_celestian_classifier = None
        self.current_classification_spectrum = None
        
        # Initialize Hey classifiers if available
        if HEY_CLASSIFICATION_AVAILABLE:
            try:
                self.hey_classifier = ImprovedHeyClassifier()
                self.hey_celestian_classifier = HeyCelestianClassifier()
                print("Hey Classification System initialized successfully")
            except Exception as e:
                print(f"Error initializing Hey classifiers: {e}")
                self.hey_classifier = None
                self.hey_celestian_classifier = None
        
        # Set window properties
        self.setWindowTitle("RamanLab - Database Browser")
        self.setMinimumSize(1200, 800)
        self.resize(1400, 900)
        
        # Create the UI
        self.setup_ui()
        
        # Initialize data
        self.update_spectrum_list()
        self.update_stats()
        self.update_hey_index_data()
    
    def setup_ui(self):
        """Set up the user interface."""
        layout = QVBoxLayout(self)
        
        # Create tab widget
        self.tab_widget = QTabWidget()
        layout.addWidget(self.tab_widget)
        
        # Create tabs
        self.create_main_browser_tab()
        self.create_hey_index_tab()
        self.create_hey_classification_tab()
        self.create_add_spectrum_tab()
        self.create_batch_import_tab()
        
        # Close button
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)
    
    def create_main_browser_tab(self):
        """Create the main database browser tab."""
        tab = QWidget()
        layout = QHBoxLayout(tab)
        
        # Create main splitter
        splitter = QSplitter(Qt.Horizontal)
        layout.addWidget(splitter)
        
        # Left panel
        self.create_left_panel(splitter)
        
        # Right panel
        self.create_right_panel(splitter)
        
        # Set splitter proportions and prevent resizing
        splitter.setSizes([350, 850])
        # Prevent automatic resizing of panels
        splitter.setChildrenCollapsible(False)
        # Keep the left panel at a fixed size
        splitter.widget(0).setMinimumWidth(350)
        splitter.widget(0).setMaximumWidth(350)
        
        self.tab_widget.addTab(tab, "Database Browser")
    
    def create_hey_index_tab(self):
        """Create the Hey Index editing tab."""
        tab = QWidget()
        layout = QHBoxLayout(tab)
        
        # Create main splitter
        splitter = QSplitter(Qt.Horizontal)
        layout.addWidget(splitter)
        
        # Left panel for search and list
        self.create_hey_index_left_panel(splitter)
        
        # Right panel for editing and metadata
        self.create_hey_index_right_panel(splitter)
        
        # Set splitter proportions
        splitter.setSizes([350, 850])
        splitter.setChildrenCollapsible(False)
        splitter.widget(0).setMinimumWidth(350)
        splitter.widget(0).setMaximumWidth(350)
        
        self.tab_widget.addTab(tab, "Hey Index")
    
    def create_hey_classification_tab(self):
        """Create the Hey Classification tab with subtabs for dual classification system."""
        if not HEY_CLASSIFICATION_AVAILABLE:
            # Create a simple info tab if the system isn't available
            tab = QWidget()
            layout = QVBoxLayout(tab)
            
            info_label = QLabel(
                "Hey Classification System Not Available\n\n"
                "The Hey Classification system requires the Hey_class module.\n"
                "Please ensure the Hey_class folder is in your RamanLab directory."
            )
            info_label.setAlignment(Qt.AlignCenter)
            info_label.setStyleSheet("color: #666; font-size: 12px; padding: 20px;")
            layout.addWidget(info_label)
            
            self.tab_widget.addTab(tab, "Hey Classification (Unavailable)")
            return
        
        # Create main tab widget
        tab = QWidget()
        main_layout = QVBoxLayout(tab)
        
        # Add header info
        header_label = QLabel("ðŸ”¬ Hey & Hey-Celestian Classification System")
        header_label.setAlignment(Qt.AlignCenter)
        header_label.setFont(QFont("Arial", 14, QFont.Bold))
        header_label.setStyleSheet("color: #2E7D32; padding: 10px; background: #E8F5E8; border-radius: 5px; margin-bottom: 10px;")
        main_layout.addWidget(header_label)
        
        # Create subtab widget
        self.hey_classification_tabs = QTabWidget()
        main_layout.addWidget(self.hey_classification_tabs)
        
        # Create subtabs
        self.create_single_classification_tab()
        self.create_batch_classification_tab()
        self.create_classification_viewer_tab()
        self.create_hey_celestian_groups_tab()
        
        self.tab_widget.addTab(tab, "Hey Classification")
    
    def create_hey_index_left_panel(self, parent):
        """Create the left panel for Hey Index tab."""
        left_widget = QWidget()
        left_widget.setFixedWidth(350)
        left_layout = QVBoxLayout(left_widget)
        
        # Hey Index search group
        hey_search_group = QGroupBox("Search by Hey Index")
        hey_search_layout = QVBoxLayout(hey_search_group)
        
        # Hey Index search controls
        search_controls = QHBoxLayout()
        
        self.hey_index_search = QLineEdit()
        self.hey_index_search.setPlaceholderText("Enter Hey Index (e.g., 2.45)")
        self.hey_index_search.textChanged.connect(self.search_by_hey_index)
        search_controls.addWidget(self.hey_index_search)
        
        search_hey_btn = QPushButton("Search")
        search_hey_btn.clicked.connect(self.search_by_hey_index)
        search_controls.addWidget(search_hey_btn)
        
        hey_search_layout.addLayout(search_controls)
        
        # Hey Index range search
        range_controls = QHBoxLayout()
        range_controls.addWidget(QLabel("Range:"))
        
        self.hey_min_spin = QDoubleSpinBox()
        self.hey_min_spin.setRange(1.0, 10.0)
        self.hey_min_spin.setSingleStep(0.1)
        self.hey_min_spin.setValue(1.0)
        self.hey_min_spin.setPrefix("Min: ")
        range_controls.addWidget(self.hey_min_spin)
        
        self.hey_max_spin = QDoubleSpinBox()
        self.hey_max_spin.setRange(1.0, 10.0)
        self.hey_max_spin.setSingleStep(0.1)
        self.hey_max_spin.setValue(10.0)
        self.hey_max_spin.setPrefix("Max: ")
        range_controls.addWidget(self.hey_max_spin)
        
        search_range_btn = QPushButton("Search Range")
        search_range_btn.clicked.connect(self.search_hey_range)
        range_controls.addWidget(search_range_btn)
        
        hey_search_layout.addLayout(range_controls)
        
        # Filter controls
        filter_controls = QHBoxLayout()
        
        show_unassigned_btn = QPushButton("Show Unassigned")
        show_unassigned_btn.clicked.connect(self.show_unassigned_hey)
        filter_controls.addWidget(show_unassigned_btn)
        
        show_all_btn = QPushButton("Show All")
        show_all_btn.clicked.connect(self.show_all_hey_spectra)
        filter_controls.addWidget(show_all_btn)
        
        hey_search_layout.addLayout(filter_controls)
        
        left_layout.addWidget(hey_search_group)
        
        # Spectra list with Hey Index info
        list_group = QGroupBox("Spectra with Hey Index")
        list_layout = QVBoxLayout(list_group)
        
        self.hey_spectrum_list = QListWidget()
        self.hey_spectrum_list.currentItemChanged.connect(self.on_hey_spectrum_select)
        list_layout.addWidget(self.hey_spectrum_list)
        
        left_layout.addWidget(list_group)
        
        # Hey Index statistics
        stats_group = QGroupBox("Hey Index Statistics")
        stats_layout = QVBoxLayout(stats_group)
        
        self.hey_stats_text = QTextEdit()
        self.hey_stats_text.setMaximumHeight(120)
        self.hey_stats_text.setReadOnly(True)
        stats_layout.addWidget(self.hey_stats_text)
        
        left_layout.addWidget(stats_group)
        
        parent.addWidget(left_widget)
    
    def create_hey_index_right_panel(self, parent):
        """Create the right panel for Hey Index editing."""
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        
        # Current spectrum info group
        current_info_group = QGroupBox("Current Spectrum")
        current_info_layout = QGridLayout(current_info_group)
        
        current_info_layout.addWidget(QLabel("Name:"), 0, 0)
        self.hey_name_label = QLabel("")
        self.hey_name_label.setStyleSheet("border: 1px solid gray; padding: 2px; background: white;")
        self.hey_name_label.setWordWrap(True)
        self.hey_name_label.setMaximumHeight(40)
        current_info_layout.addWidget(self.hey_name_label, 0, 1, 1, 2)
        
        current_info_layout.addWidget(QLabel("Current Hey Index:"), 1, 0)
        self.current_hey_label = QLabel("Not assigned")
        self.current_hey_label.setStyleSheet("border: 1px solid gray; padding: 2px; background: white; font-weight: bold;")
        current_info_layout.addWidget(self.current_hey_label, 1, 1)
        
        current_info_layout.addWidget(QLabel("Mineral Name:"), 1, 2)
        self.hey_mineral_label = QLabel("")
        self.hey_mineral_label.setStyleSheet("border: 1px solid gray; padding: 2px; background: white;")
        current_info_layout.addWidget(self.hey_mineral_label, 1, 3)
        
        right_layout.addWidget(current_info_group)
        
        # Hey Index editing group
        edit_group = QGroupBox("Edit Hey Index")
        edit_layout = QVBoxLayout(edit_group)
        
        # Hey Index dropdown selection
        input_controls = QHBoxLayout()
        
        input_controls.addWidget(QLabel("Select Hey Classification:"))
        self.hey_index_dropdown = QComboBox()
        self.hey_index_dropdown.setMinimumWidth(300)
        
        # Populate with all 32 Hey Index groups
        hey_classifications = [
            "-- Select Classification --",
            "Native Elements",
            "Sulfides",
            "Sulfosalts", 
            "Halides",
            "Oxides",
            "Hydroxides",
            "Oxides and Hydroxides",
            "Carbonates",
            "Nitrates",
            "Borates",
            "Sulfates",
            "Chromates",
            "Molybdates and Tungstates",
            "Phosphates",
            "Arsenates",
            "Vanadates",
            "Silicates",
            "Silicates of Aluminum",
            "Framework Silicates",
            "Tectosilicates",
            "Chain Silicates",
            "Inosilicates",
            "Single Chain Silicates",
            "Double Chain Silicates",
            "Sheet Silicates",
            "Phyllosilicates",
            "Ring Silicates",
            "Cyclosilicates",
            "Isolated Tetrahedra Silicates",
            "Nesosilicates",
            "Linked Tetrahedra Silicates",
            "Sorosilicates"
        ]
        
        self.hey_index_dropdown.addItems(hey_classifications)
        input_controls.addWidget(self.hey_index_dropdown)
        
        input_controls.addStretch()
        edit_layout.addLayout(input_controls)
        
        # Action buttons
        action_controls = QHBoxLayout()
        
        save_hey_btn = QPushButton("Save Hey Index")
        save_hey_btn.clicked.connect(self.save_hey_index)
        save_hey_btn.setStyleSheet("""
            QPushButton {
                background-color: #28A745;
                color: white;
                border: none;
                padding: 8px;
                border-radius: 4px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #218838;
            }
        """)
        action_controls.addWidget(save_hey_btn)
        
        clear_hey_btn = QPushButton("Clear Hey Index")
        clear_hey_btn.clicked.connect(self.clear_hey_index)
        clear_hey_btn.setStyleSheet("""
            QPushButton {
                background-color: #DC3545;
                color: white;
                border: none;
                padding: 8px;
                border-radius: 4px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #C82333;
            }
        """)
        action_controls.addWidget(clear_hey_btn)
        
        action_controls.addStretch()
        edit_layout.addLayout(action_controls)
        
        right_layout.addWidget(edit_group)
        
        # Full metadata display group
        metadata_group = QGroupBox("Complete Metadata")
        metadata_layout = QVBoxLayout(metadata_group)
        
        self.hey_metadata_text = QTextEdit()
        self.hey_metadata_text.setReadOnly(True)
        self.hey_metadata_text.setFont(QFont("Courier", 9))
        metadata_layout.addWidget(self.hey_metadata_text)
        
        # Metadata actions
        metadata_actions = QHBoxLayout()
        
        refresh_metadata_btn = QPushButton("Refresh Metadata")
        refresh_metadata_btn.clicked.connect(self.refresh_hey_metadata)
        metadata_actions.addWidget(refresh_metadata_btn)
        
        edit_full_metadata_btn = QPushButton("Edit Full Metadata")
        edit_full_metadata_btn.clicked.connect(self.edit_hey_metadata)
        metadata_actions.addWidget(edit_full_metadata_btn)
        
        metadata_actions.addStretch()
        metadata_layout.addLayout(metadata_actions)
        
        right_layout.addWidget(metadata_group)
        
        parent.addWidget(right_widget)
    
    def create_left_panel(self, parent):
        """Create the left panel with search, list, and controls."""
        left_widget = QWidget()
        # Set fixed width for the left panel
        left_widget.setFixedWidth(350)
        left_layout = QVBoxLayout(left_widget)
        
        # Search group
        search_group = QGroupBox("Search")
        search_layout = QVBoxLayout(search_group)
        
        self.search_entry = QLineEdit()
        self.search_entry.setPlaceholderText("Search spectra...")
        self.search_entry.textChanged.connect(self.perform_search)
        search_layout.addWidget(self.search_entry)
        
        clear_search_btn = QPushButton("Clear Search")
        clear_search_btn.clicked.connect(self.clear_search)
        search_layout.addWidget(clear_search_btn)
        
        left_layout.addWidget(search_group)
        
        # Controls group
        controls_group = QGroupBox("Database Controls")
        controls_layout = QVBoxLayout(controls_group)
        
        refresh_btn = QPushButton("Refresh List")
        refresh_btn.clicked.connect(self.update_spectrum_list)
        controls_layout.addWidget(refresh_btn)
        
        export_btn = QPushButton("Export Spectrum")
        export_btn.clicked.connect(self.export_spectrum)
        controls_layout.addWidget(export_btn)
        
        delete_btn = QPushButton("Delete Spectrum")
        delete_btn.clicked.connect(self.delete_spectrum)
        controls_layout.addWidget(delete_btn)
        
        save_btn = QPushButton("Save Database")
        save_btn.clicked.connect(self.save_database)
        controls_layout.addWidget(save_btn)
        
        left_layout.addWidget(controls_group)
        
        # Spectrum list group
        list_group = QGroupBox("Raman Spectra")
        list_layout = QVBoxLayout(list_group)
        
        self.spectrum_list = QListWidget()
        self.spectrum_list.currentItemChanged.connect(self.on_spectrum_select)
        list_layout.addWidget(self.spectrum_list)
        
        left_layout.addWidget(list_group)
        
        # Statistics group
        stats_group = QGroupBox("Database Statistics")
        stats_layout = QVBoxLayout(stats_group)
        
        self.stats_text = QTextEdit()
        self.stats_text.setMaximumHeight(120)
        self.stats_text.setReadOnly(True)
        stats_layout.addWidget(self.stats_text)
        
        left_layout.addWidget(stats_group)
        
        parent.addWidget(left_widget)
    
    def create_right_panel(self, parent):
        """Create the right panel with spectrum details and visualization."""
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        
        # Spectrum information group
        info_group = QGroupBox("Spectrum Information")
        info_layout = QGridLayout(info_group)
        
        # Create info labels
        row = 0
        info_layout.addWidget(QLabel("Name:"), row, 0)
        self.name_label = QLabel("")
        self.name_label.setStyleSheet("border: 1px solid gray; padding: 2px; background: white;")
        # Prevent text from causing layout changes
        self.name_label.setWordWrap(True)
        self.name_label.setMaximumHeight(40)
        self.name_label.setMinimumHeight(25)
        info_layout.addWidget(self.name_label, row, 1, 1, 2)  # Span 2 columns now
        
        info_layout.addWidget(QLabel("Data Points:"), row, 3)
        self.data_points_label = QLabel("")
        self.data_points_label.setStyleSheet("border: 1px solid gray; padding: 2px; background: white;")
        self.data_points_label.setMinimumHeight(25)
        info_layout.addWidget(self.data_points_label, row, 4)
        
        row += 1
        info_layout.addWidget(QLabel("Wavenumber Range:"), row, 0)
        self.range_label = QLabel("")
        self.range_label.setStyleSheet("border: 1px solid gray; padding: 2px; background: white;")
        self.range_label.setMinimumHeight(25)
        info_layout.addWidget(self.range_label, row, 1, 1, 2)  # Span 2 columns
        
        row += 1
        info_layout.addWidget(QLabel("Description:"), row, 0)
        self.description_label = QLabel("")
        self.description_label.setStyleSheet("border: 1px solid gray; padding: 2px; background: white;")
        # Allow description to wrap but with fixed height
        self.description_label.setWordWrap(True)
        self.description_label.setMaximumHeight(60)
        self.description_label.setMinimumHeight(25)
        info_layout.addWidget(self.description_label, row, 1, 1, 4)  # Span all remaining columns
        
        # Control buttons
        button_layout = QVBoxLayout()
        view_metadata_btn = QPushButton("View Metadata")
        view_metadata_btn.clicked.connect(self.view_metadata)
        button_layout.addWidget(view_metadata_btn)
        
        edit_metadata_btn = QPushButton("Edit Metadata")
        edit_metadata_btn.clicked.connect(self.edit_metadata)
        button_layout.addWidget(edit_metadata_btn)
        
        load_spectrum_btn = QPushButton("Load in Main App")
        load_spectrum_btn.clicked.connect(self.load_spectrum_in_main)
        button_layout.addWidget(load_spectrum_btn)
        
        info_layout.addLayout(button_layout, 0, 5, 3, 1)  # Adjust column position
        
        right_layout.addWidget(info_group)
        
        # Peak analysis group
        peak_group = QGroupBox("Peak Analysis")
        peak_layout = QVBoxLayout(peak_group)
        
        # Peak controls
        peak_controls_layout = QHBoxLayout()
        
        peak_controls_layout.addWidget(QLabel("Min Height:"))
        self.height_spin = QDoubleSpinBox()
        self.height_spin.setRange(0.0, 10.0)
        self.height_spin.setSingleStep(0.1)
        self.height_spin.setValue(0.1)
        peak_controls_layout.addWidget(self.height_spin)
        
        peak_controls_layout.addWidget(QLabel("Min Prominence:"))
        self.prominence_spin = QDoubleSpinBox()
        self.prominence_spin.setRange(0.0, 1.0)
        self.prominence_spin.setSingleStep(0.01)
        self.prominence_spin.setValue(0.05)
        peak_controls_layout.addWidget(self.prominence_spin)
        
        peak_controls_layout.addWidget(QLabel("Min Distance:"))
        self.distance_spin = QSpinBox()
        self.distance_spin.setRange(1, 100)
        self.distance_spin.setValue(10)
        peak_controls_layout.addWidget(self.distance_spin)
        
        find_peaks_btn = QPushButton("Find Peaks")
        find_peaks_btn.clicked.connect(self.find_peaks)
        peak_controls_layout.addWidget(find_peaks_btn)
        
        clear_peaks_btn = QPushButton("Clear Peaks")
        clear_peaks_btn.clicked.connect(self.clear_peaks)
        peak_controls_layout.addWidget(clear_peaks_btn)
        
        peak_controls_layout.addStretch()
        peak_layout.addLayout(peak_controls_layout)
        
        # Peak comparison section
        peak_comparison_layout = QHBoxLayout()
        
        # Stored peaks column
        stored_group = QGroupBox("Stored in Database")
        stored_layout = QVBoxLayout(stored_group)
        self.stored_peaks_list = QListWidget()
        self.stored_peaks_list.setMaximumHeight(100)
        stored_layout.addWidget(self.stored_peaks_list)
        peak_comparison_layout.addWidget(stored_group)
        
        # Detected peaks column  
        detected_group = QGroupBox("Currently Detected")
        detected_layout = QVBoxLayout(detected_group)
        self.detected_peaks_list = QListWidget()
        self.detected_peaks_list.setMaximumHeight(100)
        detected_layout.addWidget(self.detected_peaks_list)
        peak_comparison_layout.addWidget(detected_group)
        
        peak_layout.addLayout(peak_comparison_layout)
        
        # Peak action buttons
        peak_action_layout = QHBoxLayout()
        
        commit_peaks_btn = QPushButton("Commit Detected Peaks to Database")
        commit_peaks_btn.clicked.connect(self.commit_peaks_to_database)
        commit_peaks_btn.setStyleSheet("""
            QPushButton {
                background-color: #28A745;
                color: white;
                border: none;
                padding: 8px;
                border-radius: 4px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #218838;
            }
            QPushButton:pressed {
                background-color: #1E7E34;
            }
        """)
        peak_action_layout.addWidget(commit_peaks_btn)
        
        show_all_peaks_btn = QPushButton("View All Database Peaks")
        show_all_peaks_btn.clicked.connect(self.show_all_database_peaks)
        show_all_peaks_btn.setStyleSheet("""
            QPushButton {
                background-color: #6C757D;
                color: white;
                border: none;
                padding: 8px;
                border-radius: 4px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #5A6268;
            }
        """)
        peak_action_layout.addWidget(show_all_peaks_btn)
        
        peak_action_layout.addStretch()
        peak_layout.addLayout(peak_action_layout)
        
        right_layout.addWidget(peak_group)
        
        # Visualization group
        viz_group = QGroupBox("Spectrum Visualization")
        viz_layout = QVBoxLayout(viz_group)
        
        # Plot controls
        plot_controls_layout = QHBoxLayout()
        self.show_peaks_checkbox = QCheckBox("Show Peaks")
        self.show_peaks_checkbox.setChecked(True)
        self.show_peaks_checkbox.toggled.connect(self.update_plot)
        plot_controls_layout.addWidget(self.show_peaks_checkbox)
        plot_controls_layout.addStretch()
        viz_layout.addLayout(plot_controls_layout)
        
        # Create matplotlib figure
        self.figure = Figure(figsize=(10, 6))
        self.canvas = FigureCanvas(self.figure)
        self.toolbar = NavigationToolbar(self.canvas, viz_group)
        
        viz_layout.addWidget(self.toolbar)
        viz_layout.addWidget(self.canvas)
        
        # Create the plot
        self.ax = self.figure.add_subplot(111)
        self.ax.set_xlabel("Wavenumber (cmâ»Â¹)")
        self.ax.set_ylabel("Intensity (a.u.)")
        self.ax.set_title("Raman Spectrum")
        self.ax.grid(True, alpha=0.3)
        
        right_layout.addWidget(viz_group)
        
        parent.addWidget(right_widget)
    
    def create_add_spectrum_tab(self):
        """Create the add spectrum tab."""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        
        # Instructions
        instructions = QLabel("Add a new spectrum to the database by importing from file or manual entry.")
        instructions.setWordWrap(True)
        layout.addWidget(instructions)
        
        # File import group
        file_group = QGroupBox("Import from File")
        file_layout = QVBoxLayout(file_group)
        
        file_controls = QHBoxLayout()
        self.file_path_edit = QLineEdit()
        self.file_path_edit.setPlaceholderText("Select spectrum file...")
        file_controls.addWidget(self.file_path_edit)
        
        browse_btn = QPushButton("Browse")
        browse_btn.clicked.connect(self.browse_spectrum_file)
        file_controls.addWidget(browse_btn)
        
        file_layout.addLayout(file_controls)
        
        preview_btn = QPushButton("Preview Spectrum")
        preview_btn.clicked.connect(self.preview_spectrum)
        file_layout.addWidget(preview_btn)
        
        layout.addWidget(file_group)
        
        # Metadata group
        metadata_group = QGroupBox("Spectrum Metadata")
        metadata_layout = QFormLayout(metadata_group)
        
        self.spectrum_name_edit = QLineEdit()
        metadata_layout.addRow("Spectrum Name:", self.spectrum_name_edit)
        
        self.mineral_name_edit = QLineEdit()
        metadata_layout.addRow("Mineral Name:", self.mineral_name_edit)
        
        self.description_edit = QTextEdit()
        self.description_edit.setMaximumHeight(80)
        metadata_layout.addRow("Description:", self.description_edit)
        
        self.laser_wavelength_edit = QLineEdit()
        self.laser_wavelength_edit.setPlaceholderText("e.g., 532 nm")
        metadata_layout.addRow("Laser Wavelength:", self.laser_wavelength_edit)
        
        layout.addWidget(metadata_group)
        
        # Action buttons
        button_layout = QHBoxLayout()
        
        add_btn = QPushButton("Add to Database")
        add_btn.clicked.connect(self.add_spectrum_to_database)
        button_layout.addWidget(add_btn)
        
        clear_btn = QPushButton("Clear Fields")
        clear_btn.clicked.connect(self.clear_add_fields)
        button_layout.addWidget(clear_btn)
        
        button_layout.addStretch()
        layout.addLayout(button_layout)
        
        layout.addStretch()
        
        self.tab_widget.addTab(tab, "Add Spectrum")
    
    def create_batch_import_tab(self):
        """Create the batch import tab."""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        
        # Instructions
        instructions = QLabel("Import multiple spectrum files from a directory or migrate existing database.")
        instructions.setWordWrap(True)
        layout.addWidget(instructions)
        
        # Database Migration Section
        migration_group = QGroupBox("Database Migration")
        migration_layout = QVBoxLayout(migration_group)
        
        migration_info = QLabel(
            "If you have an existing raman_database.pkl file from the Tkinter version, "
            "use this option to migrate it to the Qt6 format. The migration will "
            "preserve all your spectra and metadata."
        )
        migration_info.setWordWrap(True)
        migration_layout.addWidget(migration_info)
        
        migration_buttons = QHBoxLayout()
        
        migrate_btn = QPushButton("Migrate Legacy Database")
        migrate_btn.clicked.connect(self.migrate_legacy_database)
        migration_buttons.addWidget(migrate_btn)
        
        browse_pkl_btn = QPushButton("Browse for PKL File")
        browse_pkl_btn.clicked.connect(self.browse_pkl_file)
        migration_buttons.addWidget(browse_pkl_btn)
        
        migration_buttons.addStretch()
        migration_layout.addLayout(migration_buttons)
        
        # Migration status
        self.migration_status_label = QLabel("Ready to migrate database...")
        migration_layout.addWidget(self.migration_status_label)
        
        layout.addWidget(migration_group)
        
        # Database Export/Import Section
        export_import_group = QGroupBox("Database Export/Import")
        export_import_layout = QVBoxLayout(export_import_group)
        
        export_import_info = QLabel(
            "Export your migrated database for distribution, or import a pre-migrated "
            "database to avoid manual migration on new installations."
        )
        export_import_info.setWordWrap(True)
        export_import_layout.addWidget(export_import_info)
        
        export_import_buttons = QHBoxLayout()
        
        export_db_btn = QPushButton("Export Database")
        export_db_btn.clicked.connect(self.export_database)
        export_import_buttons.addWidget(export_db_btn)
        
        import_db_btn = QPushButton("Import Database")
        import_db_btn.clicked.connect(self.import_database)
        export_import_buttons.addWidget(import_db_btn)
        
        export_import_buttons.addStretch()
        export_import_layout.addLayout(export_import_buttons)
        
        # Export/Import status
        self.export_import_status_label = QLabel("Ready for database export/import operations...")
        export_import_layout.addWidget(self.export_import_status_label)
        
        layout.addWidget(export_import_group)
        
        # Directory selection for batch import
        dir_group = QGroupBox("Batch Import from Directory")
        dir_layout = QVBoxLayout(dir_group)
        
        dir_controls = QHBoxLayout()
        self.batch_dir_edit = QLineEdit()
        self.batch_dir_edit.setPlaceholderText("Select directory containing spectrum files...")
        dir_controls.addWidget(self.batch_dir_edit)
        
        browse_dir_btn = QPushButton("Browse Directory")
        browse_dir_btn.clicked.connect(self.browse_batch_directory)
        dir_controls.addWidget(browse_dir_btn)
        
        dir_layout.addLayout(dir_controls)
        layout.addWidget(dir_group)
        
        # Import settings
        settings_group = QGroupBox("Import Settings")
        settings_layout = QFormLayout(settings_group)
        
        self.file_pattern_edit = QLineEdit("*.txt")
        settings_layout.addRow("File Pattern:", self.file_pattern_edit)
        
        self.skip_existing_checkbox = QCheckBox()
        self.skip_existing_checkbox.setChecked(True)
        settings_layout.addRow("Skip Existing:", self.skip_existing_checkbox)
        
        layout.addWidget(settings_group)
        
        # Progress
        progress_group = QGroupBox("Import Progress")
        progress_layout = QVBoxLayout(progress_group)
        
        self.batch_progress = QProgressBar()
        progress_layout.addWidget(self.batch_progress)
        
        self.batch_status_label = QLabel("Ready to import...")
        progress_layout.addWidget(self.batch_status_label)
        
        layout.addWidget(progress_group)
        
        # Action buttons
        batch_button_layout = QHBoxLayout()
        
        start_batch_btn = QPushButton("Start Batch Import")
        start_batch_btn.clicked.connect(self.start_batch_import)
        batch_button_layout.addWidget(start_batch_btn)
        
        cancel_batch_btn = QPushButton("Cancel Import")
        cancel_batch_btn.clicked.connect(self.cancel_batch_import)
        batch_button_layout.addWidget(cancel_batch_btn)
        
        batch_button_layout.addStretch()
        layout.addLayout(batch_button_layout)
        
        layout.addStretch()
        
        self.tab_widget.addTab(tab, "Batch Import & Migration")
    
    # Event handlers and functionality methods
    def update_spectrum_list(self):
        """Update the spectrum list."""
        self.spectrum_list.clear()
        
        # Get all spectra from database
        for name in sorted(self.raman_db.database.keys()):
            item = QListWidgetItem(name)
            self.spectrum_list.addItem(item)
    
    def on_spectrum_select(self, current, previous):
        """Handle spectrum selection."""
        if current is None:
            return
        
        spectrum_name = current.text()
        self.current_spectrum = self.raman_db.database.get(spectrum_name)
        
        if self.current_spectrum:
            # Update name label with mineral name if available, otherwise use spectrum name
            metadata = self.current_spectrum.get('metadata', {})
            mineral_name = metadata.get('mineral_name', '').strip()
            
            # NOTE: Database metadata keys are stored in ALL UPPERCASE (e.g., 'DESCRIPTION', 'NAME', 'LOCALITY')
            # Always check for uppercase versions when accessing metadata fields
            
            if mineral_name and mineral_name.lower() != 'unknown':
                # Use mineral name from metadata if available and not 'unknown'
                display_name = mineral_name
            else:
                # Try to extract mineral name from filename pattern
                # Look for pattern like "Mineral__R123456__..." and extract "Mineral"
                if '__' in spectrum_name:
                    potential_mineral = spectrum_name.split('__')[0].strip()
                    # Check if it looks like a mineral name (not empty and reasonable length)
                    if potential_mineral and len(potential_mineral) > 1 and len(potential_mineral) < 50:
                        display_name = potential_mineral
                    else:
                        display_name = spectrum_name
                else:
                    # Fall back to full spectrum name if no pattern found
                    display_name = spectrum_name
            
            self.name_label.setText(display_name)
            self.data_points_label.setText(str(len(self.current_spectrum['wavenumbers'])))
            
            # Handle description - check multiple possible keys (database uses uppercase keys)
            description = ''
            description_keys = ['description', 'Description', 'DESCRIPTION', 'desc', 'notes', 'Notes', 'comment', 'Comment']
            for key in description_keys:
                if key in metadata and metadata[key]:
                    description = str(metadata[key]).strip()
                    break
            
            if not description:
                description = 'No description'
            self.description_label.setText(description)
            
            wavenumbers = np.array(self.current_spectrum['wavenumbers'])
            self.range_label.setText(f"{wavenumbers.min():.1f} - {wavenumbers.max():.1f} cmâ»Â¹")
            
            # Clear any detected peaks when switching spectra
            self.current_peaks = None
            
            # Update peak lists to show stored peaks
            self.update_peak_lists()
            
            # Update plot
            self.update_plot()
    
    def update_plot(self):
        """Update the spectrum plot."""
        self.ax.clear()
        
        if self.current_spectrum:
            wavenumbers = np.array(self.current_spectrum['wavenumbers'])
            intensities = np.array(self.current_spectrum['intensities'])
            
            # Plot spectrum
            self.ax.plot(wavenumbers, intensities, 'b-', linewidth=1)
            
            # Plot peaks if enabled and available
            if self.show_peaks_checkbox.isChecked() and self.current_peaks is not None:
                peak_positions = wavenumbers[self.current_peaks]
                peak_intensities = intensities[self.current_peaks]
                self.ax.plot(peak_positions, peak_intensities, 'ro', markersize=6)
            
            self.ax.set_xlabel("Wavenumber (cmâ»Â¹)")
            self.ax.set_ylabel("Intensity (a.u.)")
            self.ax.set_title("Raman Spectrum")
            self.ax.grid(True, alpha=0.3)
        
        self.canvas.draw()
    
    def find_peaks(self):
        """Find peaks in the current spectrum."""
        if not self.current_spectrum:
            QMessageBox.warning(self, "No Spectrum", "Please select a spectrum first.")
            return
        
        intensities = np.array(self.current_spectrum['intensities'])
        wavenumbers = np.array(self.current_spectrum['wavenumbers'])
        
        # Get parameters
        height_threshold = self.height_spin.value() * np.max(intensities)
        prominence_threshold = self.prominence_spin.value() * np.max(intensities)
        distance = self.distance_spin.value()
        
        # Find peaks
        self.current_peaks, properties = find_peaks(
            intensities,
            height=height_threshold,
            prominence=prominence_threshold,
            distance=distance
        )
        
        # Update peak lists
        self.update_peak_lists()
        
        # Update plot
        self.update_plot()
        
        print(f"DEBUG: Found {len(self.current_peaks)} peaks at wavenumbers: {wavenumbers[self.current_peaks]}")
    
    def update_peak_lists(self):
        """Update the stored and detected peak lists."""
        self.stored_peaks_list.clear()
        self.detected_peaks_list.clear()
        
        # Show stored peaks from database
        if self.current_spectrum:
            stored_peaks = self.get_stored_peaks_for_spectrum()
            for peak in stored_peaks:
                item_text = f"{peak:.1f} cmâ»Â¹"
                self.stored_peaks_list.addItem(item_text)
        
        # Show currently detected peaks
        if self.current_peaks is not None and self.current_spectrum:
            wavenumbers = np.array(self.current_spectrum['wavenumbers'])
            
            for peak_idx in self.current_peaks:
                item_text = f"{wavenumbers[peak_idx]:.1f} cmâ»Â¹"
                self.detected_peaks_list.addItem(item_text)
    
    def clear_peaks(self):
        """Clear the peaks."""
        self.current_peaks = None
        self.update_peak_lists()
        self.update_plot()

    def get_stored_peaks_for_spectrum(self):
        """Get stored peak positions for the current spectrum."""
        if not self.current_spectrum:
            return []
        
        peaks_data = self.current_spectrum.get('peaks', [])
        peak_positions = []
        
        # Handle different peak storage formats
        if isinstance(peaks_data, dict) and peaks_data.get("wavenumbers") is not None:
            # Original app format - convert wavenumbers to indices
            peak_wavenumbers = np.array(peaks_data["wavenumbers"])
            peak_positions = np.searchsorted(self.current_spectrum['wavenumbers'], peak_wavenumbers)
        elif isinstance(peaks_data, (list, tuple)):
            # Check if these are wavenumber values or indices
            if all(isinstance(p, (int, float)) and 0 <= p < len(self.current_spectrum['wavenumbers']) for p in peaks_data if p is not None):
                # Already indices
                peak_positions = np.array([int(p) for p in peaks_data if p is not None], dtype=np.int64)
            else:
                # Direct wavenumber values - convert to indices
                peak_wavenumbers = np.array([float(p) for p in peaks_data if p is not None])
                peak_positions = np.searchsorted(self.current_spectrum['wavenumbers'], peak_wavenumbers)
        else:
            peak_positions = None
        
        return peak_positions

    def commit_peaks_to_database(self):
        """Commit the currently detected peaks to the database, overwriting stored peaks."""
        if not self.current_spectrum:
            QMessageBox.warning(self, "No Spectrum", "Please select a spectrum first.")
            return
        
        if self.current_peaks is None or len(self.current_peaks) == 0:
            reply = QMessageBox.question(
                self,
                "No Peaks Detected",
                "No peaks are currently detected. Do you want to clear the stored peaks for this spectrum?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            if reply != QMessageBox.Yes:
                return
            peak_wavenumbers = []
        else:
            # Convert detected peak indices to wavenumber values
            wavenumbers = np.array(self.current_spectrum['wavenumbers'])
            peak_wavenumbers = wavenumbers[self.current_peaks].tolist()
        
        # Get the spectrum name
        current_item = self.spectrum_list.currentItem()
        if not current_item:
            QMessageBox.warning(self, "No Selection", "No spectrum selected.")
            return
        
        spectrum_name = current_item.text()
        
        # Confirm the action
        peak_count = len(peak_wavenumbers)
        reply = QMessageBox.question(
            self,
            "Commit Peaks",
            f"This will overwrite the stored peaks for '{spectrum_name}' with {peak_count} newly detected peaks.\n\n"
            f"Peak positions: {[f'{p:.1f}' for p in peak_wavenumbers[:5]]}{'...' if peak_count > 5 else ''}\n\n"
            "Are you sure you want to continue?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            try:
                # Update the peaks in the database
                self.raman_db.database[spectrum_name]['peaks'] = peak_wavenumbers
                
                # Save the database
                self.raman_db.save_database()
                
                # Update the current spectrum object
                self.current_spectrum['peaks'] = peak_wavenumbers
                
                # Refresh the peak lists
                self.update_peak_lists()
                
                QMessageBox.information(
                    self,
                    "Success",
                    f"Successfully committed {peak_count} peaks to database for '{spectrum_name}'!"
                )
                
            except Exception as e:
                QMessageBox.critical(
                    self,
                    "Error",
                    f"Failed to commit peaks to database:\n{str(e)}"
                )

    def show_all_database_peaks(self):
        """Show a dialog with all stored peaks in the database for verification."""
        if not self.raman_db.database:
            QMessageBox.information(self, "Empty Database", "No spectra in database to show peaks for.")
            return
        
        # Create dialog to show stored peaks (moved from main app)
        dialog = QDialog(self)
        dialog.setWindowTitle("Database Peak Verification")
        dialog.setMinimumSize(800, 500)
        layout = QVBoxLayout(dialog)
        
        # Create table to show peaks
        from PySide6.QtWidgets import QTableWidget, QTableWidgetItem, QHeaderView
        
        table = QTableWidget()
        table.setColumnCount(3)
        table.setHorizontalHeaderLabels(["Spectrum Name", "Number of Peaks", "Peak Positions (cmâ»Â¹)"])
        table.horizontalHeader().setStretchLastSection(True)
        
        # Populate table with database peak info
        row = 0
        for name, data in self.raman_db.database.items():
            peaks_data = data.get('peaks', [])
            
            # Use the same logic as get_stored_peaks_for_spectrum
            peak_positions = []
            if isinstance(peaks_data, dict) and peaks_data.get("wavenumbers") is not None:
                # Original app format
                db_peaks = peaks_data["wavenumbers"]
                if hasattr(db_peaks, 'tolist'):
                    peak_positions = db_peaks.tolist()
                else:
                    peak_positions = list(db_peaks)
            elif isinstance(peaks_data, (list, tuple)):
                # Check if these are wavenumber values or indices
                spectrum_wavenumbers = data.get('wavenumbers', [])
                if (len(spectrum_wavenumbers) > 0 and 
                    all(isinstance(p, (int, float)) and 0 <= p < len(spectrum_wavenumbers) for p in peaks_data if p is not None)):
                    # Legacy format: convert indices to wavenumbers
                    spectrum_wavenumbers = np.array(spectrum_wavenumbers)
                    for peak_idx in peaks_data:
                        if peak_idx is not None and 0 <= int(peak_idx) < len(spectrum_wavenumbers):
                            peak_positions.append(float(spectrum_wavenumbers[int(peak_idx)]))
                else:
                    # Direct wavenumber values
                    peak_positions = [float(p) for p in peaks_data if p is not None]
            
            table.setRowCount(row + 1)
            
            # Spectrum name
            table.setItem(row, 0, QTableWidgetItem(name))
            
            # Number of peaks
            table.setItem(row, 1, QTableWidgetItem(str(len(peak_positions))))
            
            # Peak positions (rounded to 1 decimal)
            if peak_positions:
                peaks_str = ", ".join([f"{p:.1f}" for p in sorted(peak_positions)])
            else:
                peaks_str = "No peaks stored"
            table.setItem(row, 2, QTableWidgetItem(peaks_str))
            
            row += 1
        
        # Make table read-only
        table.setEditTriggers(QTableWidget.NoEditTriggers)
        table.resizeColumnsToContents()
        layout.addWidget(table)
        
        # Info label
        info_label = QLabel(
            "This shows the peak positions currently stored in the database.\n"
            "To modify peaks: select a spectrum, detect new peaks, then click 'Commit Detected Peaks to Database'."
        )
        info_label.setStyleSheet("color: #666; font-style: italic; padding: 10px;")
        info_label.setWordWrap(True)
        layout.addWidget(info_label)
        
        # Close button
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dialog.close)
        layout.addWidget(close_btn)
        
        dialog.exec()
    
    def perform_search(self):
        """Perform search based on the search term."""
        search_term = self.search_entry.text().lower()
        
        # Clear and repopulate list based on search
        self.spectrum_list.clear()
        
        for name in sorted(self.raman_db.database.keys()):
            if search_term in name.lower():
                item = QListWidgetItem(name)
                self.spectrum_list.addItem(item)
    
    def clear_search(self):
        """Clear the search."""
        self.search_entry.clear()
        self.update_spectrum_list()
    
    def view_metadata(self):
        """View metadata for the current spectrum."""
        if not self.current_spectrum:
            QMessageBox.warning(self, "No Spectrum", "Please select a spectrum first.")
            return
        
        metadata = self.current_spectrum.get('metadata', {})
        
        # Create metadata viewer dialog
        dialog = QDialog(self)
        dialog.setWindowTitle("Spectrum Metadata")
        dialog.setMinimumSize(500, 400)
        
        layout = QVBoxLayout(dialog)
        
        text_edit = QTextEdit()
        text_edit.setReadOnly(True)
        
        # Format metadata display
        metadata_text = "Spectrum Metadata:\n\n"
        for key, value in metadata.items():
            metadata_text += f"{key.replace('_', ' ').title()}: {value}\n"
        
        if not metadata:
            metadata_text += "No metadata available."
        
        text_edit.setPlainText(metadata_text)
        layout.addWidget(text_edit)
        
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dialog.close)
        layout.addWidget(close_btn)
        
        dialog.exec()
    
    def edit_metadata(self):
        """Edit metadata for the current spectrum."""
        if not self.current_spectrum:
            QMessageBox.warning(self, "No Spectrum", "Please select a spectrum first.")
            return
        
        current_item = self.spectrum_list.currentItem()
        if not current_item:
            return
        
        spectrum_name = current_item.text()
        metadata = self.current_spectrum.get('metadata', {}).copy()  # Work with a copy
        
        # Create metadata editor dialog
        dialog = MetadataEditorDialog(metadata, spectrum_name, self)
        
        if dialog.exec() == QDialog.Accepted:
            # Get the updated metadata
            updated_metadata = dialog.get_metadata()
            
            # Update the spectrum in the database
            self.current_spectrum['metadata'] = updated_metadata
            
            # Save to database
            try:
                self.raman_db.save_database()
                
                # Update the display
                self.on_spectrum_select(current_item, None)  # Refresh the display
                
                QMessageBox.information(self, "Success", "Metadata updated successfully!")
                
            except Exception as e:
                QMessageBox.critical(self, "Save Error", f"Failed to save metadata:\n{str(e)}")

    def load_spectrum_in_main(self):
        """Load the selected spectrum in the main application."""
        if not self.current_spectrum:
            QMessageBox.warning(self, "No Spectrum", "Please select a spectrum first.")
            return
        
        # Get parent application and load spectrum
        if self.parent():
            parent_app = self.parent()
            if hasattr(parent_app, 'current_wavenumbers'):
                parent_app.current_wavenumbers = np.array(self.current_spectrum['wavenumbers'])
                parent_app.current_intensities = np.array(self.current_spectrum['intensities'])
                parent_app.processed_intensities = parent_app.current_intensities.copy()
                
                # Handle different peak storage formats
                peaks_data = self.current_spectrum.get('peaks', [])
                if isinstance(peaks_data, dict) and peaks_data.get("wavenumbers") is not None:
                    # Original app format - convert wavenumbers to indices
                    peak_wavenumbers = np.array(peaks_data["wavenumbers"])
                    parent_app.detected_peaks = np.searchsorted(parent_app.current_wavenumbers, peak_wavenumbers)
                elif isinstance(peaks_data, (list, tuple)):
                    # Check if these are wavenumber values or indices
                    if all(isinstance(p, (int, float)) and 0 <= p < len(parent_app.current_wavenumbers) for p in peaks_data if p is not None):
                        # Already indices
                        parent_app.detected_peaks = np.array([int(p) for p in peaks_data if p is not None], dtype=np.int64)
                    else:
                        # Direct wavenumber values - convert to indices
                        peak_wavenumbers = np.array([float(p) for p in peaks_data if p is not None])
                        parent_app.detected_peaks = np.searchsorted(parent_app.current_wavenumbers, peak_wavenumbers)
                else:
                    parent_app.detected_peaks = None
                
                # Update main app plot
                parent_app.update_plot()
                
                # Update info display
                metadata = self.current_spectrum.get('metadata', {})
                info_text = f"Loaded from database: {self.name_label.text()}\n"
                info_text += f"Data points: {len(parent_app.current_wavenumbers)}\n"
                info_text += f"Wavenumber range: {parent_app.current_wavenumbers.min():.1f} - {parent_app.current_wavenumbers.max():.1f} cmâ»Â¹\n"
                if metadata.get('mineral_name'):
                    info_text += f"Mineral: {metadata['mineral_name']}\n"
                
                parent_app.info_text.setPlainText(info_text)
                parent_app.status_bar.showMessage(f"Loaded from database: {self.name_label.text()}")
                
                QMessageBox.information(self, "Success", f"Spectrum loaded in main application!")

    def export_spectrum(self):
        """Export the selected spectrum."""
        if not self.current_spectrum:
            QMessageBox.warning(self, "No Spectrum", "Please select a spectrum first.")
            return
        
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Export Spectrum",
            QStandardPaths.writableLocation(QStandardPaths.DocumentsLocation),
            "Text files (*.txt);;CSV files (*.csv);;All files (*.*)"
        )
        
        if file_path:
            try:
                wavenumbers = np.array(self.current_spectrum['wavenumbers'])
                intensities = np.array(self.current_spectrum['intensities'])
                data = np.column_stack([wavenumbers, intensities])
                np.savetxt(file_path, data, delimiter='\t', header='Wavenumber\tIntensity')
                QMessageBox.information(self, "Success", f"Spectrum exported to:\n{file_path}")
            except Exception as e:
                QMessageBox.critical(self, "Export Error", f"Failed to export spectrum:\n{str(e)}")

    def delete_spectrum(self):
        """Delete the selected spectrum."""
        current_item = self.spectrum_list.currentItem()
        if not current_item:
            QMessageBox.warning(self, "No Selection", "Please select a spectrum to delete.")
            return
        
        spectrum_name = current_item.text()
        
        reply = QMessageBox.question(
            self,
            "Confirm Deletion",
            f"Are you sure you want to delete '{spectrum_name}'?\n\nThis action cannot be undone.",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            success = self.raman_db.remove_from_database(spectrum_name)
            if success:
                self.update_spectrum_list()
                self.update_stats()
                self.clear_spectrum_display()

    def clear_spectrum_display(self):
        """Clear the spectrum display."""
        self.current_spectrum = None
        self.current_peaks = None
        
        # Clear info labels
        self.name_label.setText("")
        self.data_points_label.setText("")
        self.range_label.setText("")
        self.description_label.setText("")
        
        # Clear peak table
        self.peak_table.clear()
        
        # Clear plot
        self.ax.clear()
        self.canvas.draw()

    def save_database(self):
        """Save the database."""
        success = self.raman_db.save_database()
        if success:
            QMessageBox.information(self, "Success", "Database saved successfully!")
        else:
            QMessageBox.critical(self, "Error", "Failed to save database.")

    def update_stats(self):
        """Update database statistics."""
        stats = self.raman_db.get_database_stats()
        
        stats_text = f"Database Statistics:\n\n"
        stats_text += f"Total Spectra: {stats['total_spectra']}\n"
        stats_text += f"Avg Data Points: {stats['avg_data_points']:.0f}\n"
        stats_text += f"Avg Peaks: {stats['avg_peaks']:.1f}\n"
        stats_text += f"File Size: {stats['database_size']}"
        
        self.stats_text.setPlainText(stats_text)

    # Add Spectrum Tab Methods
    def browse_spectrum_file(self):
        """Browse for spectrum file."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Spectrum File",
            QStandardPaths.writableLocation(QStandardPaths.DocumentsLocation),
            "Text files (*.txt *.csv *.dat);;All files (*.*)"
        )
        
        if file_path:
            self.file_path_edit.setText(file_path)
            # Auto-fill spectrum name from filename
            filename = Path(file_path).stem
            self.spectrum_name_edit.setText(filename)

    def preview_spectrum(self):
        """Preview the selected spectrum file."""
        file_path = self.file_path_edit.text()
        if not file_path or not os.path.exists(file_path):
            QMessageBox.warning(self, "Invalid File", "Please select a valid spectrum file.")
            return
        
        try:
            data = np.loadtxt(file_path)
            if data.ndim == 2 and data.shape[1] >= 2:
                QMessageBox.information(
                    self,
                    "Preview",
                    f"File: {Path(file_path).name}\n"
                    f"Data points: {len(data)}\n"
                    f"Wavenumber range: {data[:, 0].min():.1f} - {data[:, 0].max():.1f} cmâ»Â¹\n"
                    f"Intensity range: {data[:, 1].min():.2e} - {data[:, 1].max():.2e}"
                )
            else:
                QMessageBox.warning(self, "Invalid Format", "File must contain at least two columns.")
        except Exception as e:
            QMessageBox.critical(self, "Preview Error", f"Failed to preview file:\n{str(e)}")

    def add_spectrum_to_database(self):
        """Add spectrum to database."""
        file_path = self.file_path_edit.text()
        spectrum_name = self.spectrum_name_edit.text()
        
        if not file_path or not spectrum_name:
            QMessageBox.warning(self, "Missing Information", "Please provide file path and spectrum name.")
            return
        
        if spectrum_name in self.raman_db.database:
            QMessageBox.warning(self, "Name Exists", f"Spectrum '{spectrum_name}' already exists in database.")
            return
        
        try:
            # Load data
            data = np.loadtxt(file_path)
            if data.ndim == 2 and data.shape[1] >= 2:
                wavenumbers = data[:, 0]
                intensities = data[:, 1]
            else:
                raise ValueError("Invalid file format")
            
            # Collect metadata
            metadata = {
                'mineral_name': self.mineral_name_edit.text(),
                'description': self.description_edit.toPlainText(),
                'laser_wavelength': self.laser_wavelength_edit.text(),
                'source_file': file_path
            }
            
            # Add to database
            success = self.raman_db.add_to_database(spectrum_name, wavenumbers, intensities, metadata)
            
            if success:
                QMessageBox.information(self, "Success", f"Spectrum '{spectrum_name}' added to database!")
                self.update_spectrum_list()
                self.update_stats()
                self.clear_add_fields()
            
        except Exception as e:
            QMessageBox.critical(self, "Import Error", f"Failed to import spectrum:\n{str(e)}")

    def clear_add_fields(self):
        """Clear all add spectrum fields."""
        self.file_path_edit.clear()
        self.spectrum_name_edit.clear()
        self.mineral_name_edit.clear()
        self.description_edit.clear()
        self.laser_wavelength_edit.clear()

    # Batch Import Methods
    def browse_batch_directory(self):
        """Browse for batch import directory."""
        directory = QFileDialog.getExistingDirectory(
            self,
            "Select Directory",
            QStandardPaths.writableLocation(QStandardPaths.DocumentsLocation)
        )
        
        if directory:
            self.batch_dir_edit.setText(directory)

    def start_batch_import(self):
        """Start batch import process."""
        directory = self.batch_dir_edit.text()
        if not directory or not os.path.exists(directory):
            QMessageBox.warning(self, "Invalid Directory", "Please select a valid directory.")
            return
        
        # This would implement batch import functionality
        QMessageBox.information(self, "Coming Soon", "Batch import will be implemented in the next version.")

    def cancel_batch_import(self):
        """Cancel batch import process."""
        # Implementation for canceling batch import
        pass

    def migrate_legacy_database(self):
        """Migrate legacy raman_database.pkl to Qt6 format."""
        # Look for raman_database.pkl in current directory
        legacy_db_path = "raman_database.pkl"
        
        if not os.path.exists(legacy_db_path):
            QMessageBox.warning(
                self, 
                "Legacy Database Not Found", 
                f"Could not find raman_database.pkl in the current directory.\n\n"
                f"Current directory: {os.getcwd()}\n\n"
                f"Use 'Browse for PKL File' to locate your database file manually."
            )
            return
        
        # Confirm migration
        reply = QMessageBox.question(
            self,
            "Confirm Migration",
            f"Found legacy database: {legacy_db_path}\n"
            f"Size: {os.path.getsize(legacy_db_path) / (1024*1024):.1f} MB\n\n"
            f"This will migrate the database to Qt6 format at:\n"
            f"{self.raman_db.db_path}\n\n"
            f"Any existing Qt6 database will be backed up.\n\n"
            f"Continue with migration?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes
        )
        
        if reply != QMessageBox.Yes:
            return
        
        self._perform_migration(legacy_db_path)

    def browse_pkl_file(self):
        """Browse for legacy database PKL file to migrate."""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Legacy Raman Database File",
            os.getcwd(),
            "Pickle files (*.pkl);;All files (*.*)"
        )
        
        if not file_path:
            return
        
        # Confirm migration
        reply = QMessageBox.question(
            self,
            "Confirm Migration",
            f"Selected database: {os.path.basename(file_path)}\n"
            f"Size: {os.path.getsize(file_path) / (1024*1024):.1f} MB\n\n"
            f"This will migrate the database to Qt6 format at:\n"
            f"{self.raman_db.db_path}\n\n"
            f"Any existing Qt6 database will be backed up.\n\n"
            f"Continue with migration?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes
        )
        
        if reply != QMessageBox.Yes:
            return
        
        self._perform_migration(file_path)

    def _perform_migration(self, legacy_db_path):
        """Perform the actual database migration."""
        try:
            # Update status
            self.migration_status_label.setText("Starting migration...")
            QApplication.processEvents()
            
            # Backup existing Qt6 database if it exists
            if os.path.exists(self.raman_db.db_path):
                backup_path = str(self.raman_db.db_path) + f".backup_{int(time.time())}"
                os.rename(self.raman_db.db_path, backup_path)
                self.migration_status_label.setText(f"Backed up existing database to {os.path.basename(backup_path)}")
                QApplication.processEvents()
            
            # Load legacy database
            self.migration_status_label.setText("Loading legacy database...")
            QApplication.processEvents()
            
            with open(legacy_db_path, 'rb') as f:
                legacy_db = pickle.load(f)
            
            if not isinstance(legacy_db, dict):
                raise ValueError("Legacy database is not in expected dictionary format")
            
            self.migration_status_label.setText(f"Loaded {len(legacy_db)} entries from legacy database")
            QApplication.processEvents()
            
            # Migrate entries
            success_count = 0
            error_count = 0
            
            # Show progress dialog for large databases
            if len(legacy_db) > 10:
                progress = QProgressDialog("Migrating database entries...", "Cancel", 0, len(legacy_db), self)
                progress.setWindowModality(Qt.WindowModal)
                progress.show()
            else:
                progress = None
            
            for i, (name, entry) in enumerate(legacy_db.items()):
                if progress:
                    if progress.wasCanceled():
                        break
                    progress.setValue(i)
                    progress.setLabelText(f"Migrating: {name}")
                    QApplication.processEvents()
                
                try:
                    # Skip metadata entries
                    if name.startswith('__'):
                        continue
                    
                    # Extract data from legacy format
                    wavenumbers = entry.get('wavenumbers', [])
                    intensities = entry.get('intensities', [])
                    metadata = entry.get('metadata', {})
                    peaks = entry.get('peaks', [])
                    
                    # Convert to numpy arrays if needed
                    if not isinstance(wavenumbers, np.ndarray):
                        wavenumbers = np.array(wavenumbers)
                    if not isinstance(intensities, np.ndarray):
                        intensities = np.array(intensities)
                    
                    # Add timestamp if not present
                    if 'timestamp' not in metadata:
                        from datetime import datetime
                        metadata['timestamp'] = datetime.now().isoformat()
                    
                    # Add to Qt6 database
                    success = self.raman_db.add_to_database(
                        name=name,
                        wavenumbers=wavenumbers,
                        intensities=intensities,
                        metadata=metadata,
                        peaks=peaks
                    )
                    
                    if success:
                        success_count += 1
                    else:
                        error_count += 1
                        
                except Exception as e:
                    error_count += 1
                    print(f"Error migrating {name}: {str(e)}")
            
            if progress:
                progress.close()
            
            # Update UI
            self.update_spectrum_list()
            self.update_stats()
            
            # Show success message
            message = (
                f"Database Migration Complete!\n\n"
                f"âœ… Successfully migrated: {success_count} spectra\n"
                f"âŒ Failed migrations: {error_count} spectra\n\n"
                f"Qt6 database location:\n{self.raman_db.db_path}\n\n"
                f"You can now use all Qt6 database features!"
            )
            
            QMessageBox.information(self, "Migration Complete", message)
            self.migration_status_label.setText(f"Migration complete: {success_count} spectra migrated successfully")
            
        except Exception as e:
            error_msg = f"Migration failed: {str(e)}"
            QMessageBox.critical(self, "Migration Error", error_msg)
            self.migration_status_label.setText(f"Migration failed: {str(e)}")
            import traceback
            traceback.print_exc()
        
    def export_database(self):
        """Export the current database to a distributable file."""
        if not self.raman_db.database or len(self.raman_db.database) == 0:
            QMessageBox.warning(
                self,
                "Empty Database",
                "The database is empty. Nothing to export.\n\n"
                "Import or migrate some spectra first."
            )
            return
        
        # Get save location
        default_filename = f"RamanLab_Database_{datetime.now().strftime('%Y%m%d_%H%M%S')}.sqlite"
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Export RamanLab Database",
            os.path.join(os.path.expanduser("~"), "Desktop", default_filename),
            "SQLite Database (*.sqlite);;All files (*.*)"
        )
        
        if not file_path:
            return
        
        try:
            self.export_import_status_label.setText("Exporting database...")
            QApplication.processEvents()
            
            # Get database stats for confirmation
            stats = self.raman_db.get_database_stats()
            
            # Confirm export
            reply = QMessageBox.question(
                self,
                "Confirm Database Export",
                f"Export database with {stats['total_spectra']} spectra?\n\n"
                f"Database size: {stats['database_size']}\n"
                f"Export to: {os.path.basename(file_path)}\n\n"
                f"This will create a complete, portable database file.",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes
            )
            
            if reply != QMessageBox.Yes:
                self.export_import_status_label.setText("Export cancelled.")
                return
            
            # Save current database
            self.raman_db.save_database()
            
            # Copy the database file
            import shutil
            if os.path.exists(file_path):
                os.remove(file_path)
            
            shutil.copy2(self.raman_db.db_path, file_path)
            
            # Create an info file alongside the database
            info_file = file_path.replace('.sqlite', '_info.txt')
            with open(info_file, 'w', encoding='utf-8') as f:
                f.write(f"RamanLab Database Export\n")
                f.write(f"{'='*40}\n\n")
                f.write(f"Export Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"Database Version: Qt6 SQLite Format\n\n")
                f.write(f"Database Statistics:\n")
                f.write(f"  Total Spectra: {stats['total_spectra']}\n")
                f.write(f"  Average Data Points: {stats['avg_data_points']:.0f}\n")
                f.write(f"  Average Peaks: {stats['avg_peaks']:.1f}\n")
                f.write(f"  File Size: {stats['database_size']}\n\n")
                f.write(f"Installation Instructions:\n")
                f.write(f"1. Copy this .sqlite file to your RamanLab directory\n")
                f.write(f"2. Use 'Database > Import Database' in RamanLab\n")
                f.write(f"3. Select this file to load all {stats['total_spectra']} spectra\n\n")
                f.write(f"No migration required - ready to use!\n")
            
            # Success message
            message = (
                f"Database exported successfully!\n\n"
                f"ðŸ“„ Database file: {os.path.basename(file_path)}\n"
                f"ðŸ“‹ Info file: {os.path.basename(info_file)}\n\n"
                f"Contains {stats['total_spectra']} spectra ready for distribution.\n\n"
                f"Recipients can import this database directly without migration!"
            )
            
            QMessageBox.information(self, "Export Complete", message)
            self.export_import_status_label.setText(f"Exported {stats['total_spectra']} spectra successfully")
            
        except Exception as e:
            error_msg = f"Export failed: {str(e)}"
            QMessageBox.critical(self, "Export Error", error_msg)
            self.export_import_status_label.setText(f"Export failed: {str(e)}")
            import traceback
            traceback.print_exc()

    def import_database(self):
        """Import a pre-migrated database file."""
        # Browse for database file
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Import RamanLab Database",
            os.path.expanduser("~"),
            "SQLite Database (*.sqlite);;All files (*.*)"
        )
        
        if not file_path:
            return
        
        if not os.path.exists(file_path):
            QMessageBox.critical(self, "File Error", f"File not found: {file_path}")
            return
        
        try:
            self.export_import_status_label.setText("Validating database file...")
            QApplication.processEvents()
            
            # Validate the database file by trying to read it
            import sqlite3
            with sqlite3.connect(file_path) as conn:
                cursor = conn.cursor()
                # Check if it has the expected table structure
                cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
                tables = [row[0] for row in cursor.fetchall()]
                
                if 'spectra' not in tables:
                    raise ValueError("Not a valid RamanLab database file")
                
                # Get basic stats
                cursor.execute("SELECT COUNT(*) FROM spectra")
                count = cursor.fetchone()[0]
            
            # Confirm import
            file_size = os.path.getsize(file_path) / (1024 * 1024)  # MB
            reply = QMessageBox.question(
                self,
                "Confirm Database Import",
                f"Import database from: {os.path.basename(file_path)}\n"
                f"Contains approximately {count} spectra\n"
                f"File size: {file_size:.1f} MB\n\n"
                f"This will replace your current database.\n"
                f"Your existing database will be backed up first.\n\n"
                f"Continue with import?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No  # Default to No for safety
            )
            
            if reply != QMessageBox.Yes:
                self.export_import_status_label.setText("Import cancelled.")
                return
            
            self.export_import_status_label.setText("Backing up current database...")
            QApplication.processEvents()
            
            # Backup current database if it exists
            if os.path.exists(self.raman_db.db_path):
                backup_path = str(self.raman_db.db_path) + f".backup_{int(time.time())}"
                import shutil
                shutil.copy2(self.raman_db.db_path, backup_path)
                backup_msg = f"Current database backed up to: {os.path.basename(backup_path)}"
            else:
                backup_msg = "No existing database to backup."
            
            self.export_import_status_label.setText("Importing new database...")
            QApplication.processEvents()
            
            # Copy the new database file
            import shutil
            shutil.copy2(file_path, self.raman_db.db_path)
            
            # Reload the database in memory
            self.raman_db.load_database()
            
            # Update UI
            self.update_spectrum_list()
            self.update_stats()
            
            # Success message
            stats = self.raman_db.get_database_stats()
            message = (
                f"Database imported successfully!\n\n"
                f"âœ… Imported: {stats['total_spectra']} spectra\n"
                f"âœ… Database size: {stats['database_size']}\n\n"
                f"{backup_msg}\n\n"
                f"The new database is now active and ready to use!"
            )
            
            QMessageBox.information(self, "Import Complete", message)
            self.export_import_status_label.setText(f"Imported {stats['total_spectra']} spectra successfully")
            
        except Exception as e:
            error_msg = f"Import failed: {str(e)}"
            QMessageBox.critical(self, "Import Error", error_msg)
            self.export_import_status_label.setText(f"Import failed: {str(e)}")
            import traceback
            traceback.print_exc()
    
    # Hey Index Tab Methods
    def update_hey_index_data(self):
        """Initialize the Hey Index tab with all spectra."""
        self.show_all_hey_spectra()
        self.update_hey_stats()
    
    def show_all_hey_spectra(self):
        """Show all spectra in the Hey Index list."""
        self.hey_spectrum_list.clear()
        
        for name, data in sorted(self.raman_db.database.items()):
            metadata = data.get('metadata', {})
            hey_index = self.get_hey_index_from_metadata(metadata)
            
            if hey_index is not None:
                display_text = f"{name} - Hey Index: {hey_index}"
            else:
                display_text = f"{name} - No Hey Index"
            
            item = QListWidgetItem(display_text)
            item.setData(Qt.UserRole, name)  # Store the spectrum name
            self.hey_spectrum_list.addItem(item)
    
    def get_hey_index_from_metadata(self, metadata):
        """Extract Hey Index from metadata, checking various possible keys."""
        # Check for direct numeric Hey Index keys first
        direct_keys = [
            'hey_index', 'Hey_Index', 'HEY_INDEX', 'hey', 'Hey', 'HEY',
            'Hey Index', 'Hey-Index', 'Hey_index', 'hey-index', 'HeyIndex'
        ]
        
        for key in direct_keys:
            if key in metadata:
                try:
                    return float(metadata[key])
                except (ValueError, TypeError):
                    continue
        
        # Check for keys that contain "hey" and "index" (case insensitive)
        for key, value in metadata.items():
            key_lower = key.lower()
            if 'hey' in key_lower and 'index' in key_lower:
                try:
                    return float(value)
                except (ValueError, TypeError):
                    continue
        
        # Check for Hey Classification and return the text value
        classification_keys = [
            'Hey Classification', 'hey_classification', 'Hey_Classification',
            'HEY_CLASSIFICATION', 'HEY CLASSIFICATION', 'hey classification', 
            'HeyClassification'
        ]
        
        for key in classification_keys:
            if key in metadata:
                classification = str(metadata[key]).strip()
                if classification:  # Return the actual classification text
                    return classification
        
        return None
    

    
    def search_by_hey_index(self):
        """Search spectra by specific Hey Index value."""
        search_text = self.hey_index_search.text().strip()
        
        if not search_text:
            self.show_all_hey_spectra()
            return
        
        try:
            target_hey = float(search_text)
            tolerance = 0.05  # Â±0.05 tolerance for floating point comparison
            
            self.hey_spectrum_list.clear()
            
            for name, data in sorted(self.raman_db.database.items()):
                metadata = data.get('metadata', {})
                hey_index = self.get_hey_index_from_metadata(metadata)
                
                if hey_index is not None and abs(hey_index - target_hey) <= tolerance:
                    display_text = f"{name} - Hey Index: {hey_index}"
                    item = QListWidgetItem(display_text)
                    item.setData(Qt.UserRole, name)
                    self.hey_spectrum_list.addItem(item)
            
            if self.hey_spectrum_list.count() == 0:
                item = QListWidgetItem(f"No spectra found with Hey Index â‰ˆ {target_hey}")
                self.hey_spectrum_list.addItem(item)
                
        except ValueError:
            QMessageBox.warning(self, "Invalid Input", "Please enter a valid numeric Hey Index value.")
    
    def search_hey_range(self):
        """Search spectra within a Hey Index range."""
        min_hey = self.hey_min_spin.value()
        max_hey = self.hey_max_spin.value()
        
        if min_hey > max_hey:
            QMessageBox.warning(self, "Invalid Range", "Minimum value cannot be greater than maximum value.")
            return
        
        self.hey_spectrum_list.clear()
        
        for name, data in sorted(self.raman_db.database.items()):
            metadata = data.get('metadata', {})
            hey_index = self.get_hey_index_from_metadata(metadata)
            
            if hey_index is not None and min_hey <= hey_index <= max_hey:
                display_text = f"{name} - Hey Index: {hey_index}"
                item = QListWidgetItem(display_text)
                item.setData(Qt.UserRole, name)
                self.hey_spectrum_list.addItem(item)
        
        if self.hey_spectrum_list.count() == 0:
            item = QListWidgetItem(f"No spectra found with Hey Index {min_hey} - {max_hey}")
            self.hey_spectrum_list.addItem(item)
    
    def show_unassigned_hey(self):
        """Show spectra without assigned Hey Index."""
        self.hey_spectrum_list.clear()
        
        for name, data in sorted(self.raman_db.database.items()):
            metadata = data.get('metadata', {})
            hey_index = self.get_hey_index_from_metadata(metadata)
            
            if hey_index is None:
                display_text = f"{name} - No Hey Index"
                item = QListWidgetItem(display_text)
                item.setData(Qt.UserRole, name)
                self.hey_spectrum_list.addItem(item)
        
        if self.hey_spectrum_list.count() == 0:
            item = QListWidgetItem("All spectra have assigned Hey Index values")
            self.hey_spectrum_list.addItem(item)
    
    def on_hey_spectrum_select(self, current, previous):
        """Handle Hey Index spectrum selection."""
        if current is None:
            return
        
        spectrum_name = current.data(Qt.UserRole)
        if not spectrum_name:
            # Clear display if no valid spectrum
            self.clear_hey_display()
            return
        
        self.current_hey_spectrum = self.raman_db.database.get(spectrum_name)
        
        if self.current_hey_spectrum:
            metadata = self.current_hey_spectrum.get('metadata', {})
            
            # Update spectrum name display
            mineral_name = metadata.get('mineral_name', '').strip()
            if mineral_name and mineral_name.lower() != 'unknown':
                display_name = mineral_name
            else:
                # Extract from filename if possible
                if '__' in spectrum_name:
                    potential_mineral = spectrum_name.split('__')[0].strip()
                    display_name = potential_mineral if potential_mineral else spectrum_name
                else:
                    display_name = spectrum_name
            
            self.hey_name_label.setText(display_name)
            self.hey_mineral_label.setText(mineral_name or 'Not specified')
            
            # Update current Hey Index display
            hey_index = self.get_hey_index_from_metadata(metadata)
            if hey_index is not None:
                self.current_hey_label.setText(f"{hey_index}")
                # Set the dropdown to the current classification if it exists in the list
                dropdown_index = self.hey_index_dropdown.findText(hey_index)
                if dropdown_index >= 0:
                    self.hey_index_dropdown.setCurrentIndex(dropdown_index)
                else:
                    self.hey_index_dropdown.setCurrentIndex(0)  # "-- Select Classification --"
            else:
                self.current_hey_label.setText("Not assigned")
                self.hey_index_dropdown.setCurrentIndex(0)  # "-- Select Classification --"
            
            # Update full metadata display
            self.refresh_hey_metadata()
    
    def clear_hey_display(self):
        """Clear the Hey Index display."""
        self.current_hey_spectrum = None
        self.hey_name_label.setText("")
        self.hey_mineral_label.setText("")
        self.current_hey_label.setText("Not assigned")
        self.hey_index_dropdown.setCurrentIndex(0)  # "-- Select Classification --"
        self.hey_metadata_text.clear()
    
    def save_hey_index(self):
        """Save the Hey Index value to the database."""
        if not self.current_hey_spectrum:
            QMessageBox.warning(self, "No Spectrum", "Please select a spectrum first.")
            return
        
        current_item = self.hey_spectrum_list.currentItem()
        if not current_item:
            return
        
        spectrum_name = current_item.data(Qt.UserRole)
        if not spectrum_name:
            return
        
        selected_classification = self.hey_index_dropdown.currentText()
        
        # Check if a valid classification is selected
        if selected_classification == "-- Select Classification --":
            QMessageBox.warning(self, "No Selection", "Please select a Hey Classification from the dropdown.")
            return
        
        # Confirm the action
        reply = QMessageBox.question(
            self,
            "Save Hey Index",
            f"Save Hey Classification '{selected_classification}' for '{spectrum_name}'?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes
        )
        
        if reply == QMessageBox.Yes:
            try:
                # Update the metadata
                if 'metadata' not in self.raman_db.database[spectrum_name]:
                    self.raman_db.database[spectrum_name]['metadata'] = {}
                
                self.raman_db.database[spectrum_name]['metadata']['HEY CLASSIFICATION'] = selected_classification
                
                # Save the database
                self.raman_db.save_database()
                
                # Update the current spectrum object
                self.current_hey_spectrum['metadata']['HEY CLASSIFICATION'] = selected_classification
                
                # Update displays
                self.current_hey_label.setText(f"{selected_classification}")
                self.refresh_hey_metadata()
                self.update_hey_stats()
                
                # Update the list display
                self.show_all_hey_spectra()
                
                QMessageBox.information(
                    self,
                    "Success",
                    f"Hey Classification '{selected_classification}' saved for '{spectrum_name}'!"
                )
                
            except Exception as e:
                QMessageBox.critical(
                    self,
                    "Error",
                    f"Failed to save Hey Index:\n{str(e)}"
                )
    
    def clear_hey_index(self):
        """Clear the Hey Index value from the database."""
        if not self.current_hey_spectrum:
            QMessageBox.warning(self, "No Spectrum", "Please select a spectrum first.")
            return
        
        current_item = self.hey_spectrum_list.currentItem()
        if not current_item:
            return
        
        spectrum_name = current_item.data(Qt.UserRole)
        if not spectrum_name:
            return
        
        # Confirm the action
        reply = QMessageBox.question(
            self,
            "Clear Hey Index",
            f"Remove Hey Index assignment for '{spectrum_name}'?\n\nThis cannot be undone.",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            try:
                metadata = self.raman_db.database[spectrum_name].get('metadata', {})
                
                # Remove Hey Index from all possible keys
                hey_keys = ['hey_index', 'Hey_Index', 'HEY_INDEX', 'hey', 'Hey', 'HEY']
                for key in hey_keys:
                    if key in metadata:
                        del metadata[key]
                
                # Save the database
                self.raman_db.save_database()
                
                # Update displays
                self.current_hey_label.setText("Not assigned")
                self.refresh_hey_metadata()
                self.update_hey_stats()
                
                # Update the list display
                self.show_all_hey_spectra()
                
                QMessageBox.information(
                    self,
                    "Success",
                    f"Hey Index cleared for '{spectrum_name}'!"
                )
                
            except Exception as e:
                QMessageBox.critical(
                    self,
                    "Error",
                    f"Failed to clear Hey Index:\n{str(e)}"
                )
    
    def refresh_hey_metadata(self):
        """Refresh the metadata display for the current spectrum."""
        if not self.current_hey_spectrum:
            self.hey_metadata_text.clear()
            return
        
        metadata = self.current_hey_spectrum.get('metadata', {})
        
        # Format metadata display with proper alignment
        metadata_text = "Complete Spectrum Metadata:\n"
        metadata_text += "=" * 50 + "\n\n"
        
        if metadata:
            # Sort metadata keys for consistent display
            for key in sorted(metadata.keys()):
                value = metadata[key]
                # Format key for display
                display_key = key.replace('_', ' ').title()
                
                # Special formatting for Hey Index
                if 'hey' in key.lower():
                    metadata_text += f"ðŸ” {display_key:20}: {value}\n"
                else:
                    metadata_text += f"   {display_key:20}: {value}\n"
        else:
            metadata_text += "No metadata available for this spectrum.\n"
        
        # Add spectrum data info
        metadata_text += f"\n{'-' * 50}\n"
        metadata_text += "Spectrum Data Information:\n"
        metadata_text += f"   Wavenumber Points   : {len(self.current_hey_spectrum.get('wavenumbers', []))}\n"
        metadata_text += f"   Intensity Points    : {len(self.current_hey_spectrum.get('intensities', []))}\n"
        
        wavenumbers = np.array(self.current_hey_spectrum.get('wavenumbers', []))
        if len(wavenumbers) > 0:
            metadata_text += f"   Wavenumber Range    : {wavenumbers.min():.1f} - {wavenumbers.max():.1f} cmâ»Â¹\n"
        
        peaks = self.current_hey_spectrum.get('peaks', [])
        if peaks:
            metadata_text += f"   Stored Peaks        : {len(peaks)} peaks\n"
        
        self.hey_metadata_text.setPlainText(metadata_text)
    
    def edit_hey_metadata(self):
        """Edit the full metadata for the current spectrum."""
        if not self.current_hey_spectrum:
            QMessageBox.warning(self, "No Spectrum", "Please select a spectrum first.")
            return
        
        current_item = self.hey_spectrum_list.currentItem()
        if not current_item:
            return
        
        spectrum_name = current_item.data(Qt.UserRole)
        if not spectrum_name:
            return
        
        metadata = self.current_hey_spectrum.get('metadata', {}).copy()
        
        # Create metadata editor dialog (reuse existing one)
        dialog = MetadataEditorDialog(metadata, spectrum_name, self)
        
        if dialog.exec() == QDialog.Accepted:
            # Get the updated metadata
            updated_metadata = dialog.get_metadata()
            
            # Update the spectrum in the database
            self.current_hey_spectrum['metadata'] = updated_metadata
            self.raman_db.database[spectrum_name]['metadata'] = updated_metadata
            
            # Save to database
            try:
                self.raman_db.save_database()
                
                # Update the display
                self.on_hey_spectrum_select(current_item, None)  # Refresh the display
                self.update_hey_stats()
                self.show_all_hey_spectra()
                
                QMessageBox.information(self, "Success", "Metadata updated successfully!")
                
            except Exception as e:
                QMessageBox.critical(self, "Save Error", f"Failed to save metadata:\n{str(e)}")
    
    def update_hey_stats(self):
        """Update Hey Index statistics."""
        hey_values = []
        assigned_count = 0
        total_count = len(self.raman_db.database)
        
        for name, data in self.raman_db.database.items():
            metadata = data.get('metadata', {})
            hey_index = self.get_hey_index_from_metadata(metadata)
            
            if hey_index is not None:
                hey_values.append(hey_index)
                assigned_count += 1
        
        stats_text = "Hey Index Statistics:\n\n"
        stats_text += f"Total Spectra: {total_count}\n"
        stats_text += f"With Hey Index: {assigned_count}\n"
        stats_text += f"Unassigned: {total_count - assigned_count}\n"
        
        if hey_values:
            # Count the frequency of each classification
            from collections import Counter
            classification_counts = Counter(hey_values)
            
            stats_text += f"\nHey Classifications Found:\n"
            for classification, count in sorted(classification_counts.items()):
                percentage = (count / assigned_count) * 100
                stats_text += f"  {classification}: {count} ({percentage:.1f}%)\n"
        
        self.hey_stats_text.setPlainText(stats_text)
    
    # Hey Classification Tab Methods
    def create_single_classification_tab(self):
        """Create subtab for single spectrum classification."""
        tab = QWidget()
        layout = QHBoxLayout(tab)
        
        # Create splitter
        splitter = QSplitter(Qt.Horizontal)
        layout.addWidget(splitter)
        
        # Left panel - spectrum selection
        left_widget = QWidget()
        left_widget.setFixedWidth(350)
        left_layout = QVBoxLayout(left_widget)
        
        # Spectrum selection group
        selection_group = QGroupBox("Select Spectrum for Classification")
        selection_layout = QVBoxLayout(selection_group)
        
        # Search for spectra
        search_layout = QHBoxLayout()
        self.classification_search = QLineEdit()
        self.classification_search.setPlaceholderText("Search spectra...")
        self.classification_search.textChanged.connect(self.search_classification_spectra)
        search_layout.addWidget(self.classification_search)
        
        clear_search_btn = QPushButton("Clear")
        clear_search_btn.clicked.connect(self.clear_classification_search)
        search_layout.addWidget(clear_search_btn)
        selection_layout.addLayout(search_layout)
        
        # Spectrum list
        self.classification_spectrum_list = QListWidget()
        self.classification_spectrum_list.currentItemChanged.connect(self.on_classification_spectrum_select)
        selection_layout.addWidget(self.classification_spectrum_list)
        
        left_layout.addWidget(selection_group)
        
        # Current classification status
        status_group = QGroupBox("Current Classifications")
        status_layout = QVBoxLayout(status_group)
        
        self.current_classifications_text = QTextEdit()
        self.current_classifications_text.setMaximumHeight(150)
        self.current_classifications_text.setReadOnly(True)
        status_layout.addWidget(self.current_classifications_text)
        
        left_layout.addWidget(status_group)
        
        splitter.addWidget(left_widget)
        
        # Right panel - classification controls and results
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        
        # Current spectrum info
        info_group = QGroupBox("Current Spectrum Information")
        info_layout = QGridLayout(info_group)
        
        info_layout.addWidget(QLabel("Name:"), 0, 0)
        self.classification_name_label = QLabel("")
        self.classification_name_label.setStyleSheet("border: 1px solid gray; padding: 4px; background: white;")
        info_layout.addWidget(self.classification_name_label, 0, 1, 1, 2)
        
        info_layout.addWidget(QLabel("Chemical Formula:"), 1, 0)
        self.classification_formula_edit = QLineEdit()
        self.classification_formula_edit.setPlaceholderText("Enter or extract chemical formula")
        info_layout.addWidget(self.classification_formula_edit, 1, 1)
        
        extract_btn = QPushButton("Extract from Metadata")
        extract_btn.clicked.connect(self.extract_formula_from_metadata)
        info_layout.addWidget(extract_btn, 1, 2)
        
        debug_btn = QPushButton("Show Metadata")
        debug_btn.clicked.connect(self.show_metadata_debug)
        info_layout.addWidget(debug_btn, 2, 2)
        
        info_layout.addWidget(QLabel("Elements:"), 2, 0)
        self.classification_elements_label = QLabel("")
        self.classification_elements_label.setStyleSheet("border: 1px solid gray; padding: 4px; background: white;")
        info_layout.addWidget(self.classification_elements_label, 2, 1, 1, 2)
        
        right_layout.addWidget(info_group)
        
        # Classification options
        options_group = QGroupBox("Classification Options")
        options_layout = QVBoxLayout(options_group)
        
        # Checkboxes for which systems to use
        classifier_options = QHBoxLayout()
        self.use_traditional_hey = QCheckBox("Traditional Hey Classification")
        self.use_traditional_hey.setChecked(True)
        classifier_options.addWidget(self.use_traditional_hey)
        
        self.use_hey_celestian = QCheckBox("Hey-Celestian Vibrational Classification")
        self.use_hey_celestian.setChecked(True)
        classifier_options.addWidget(self.use_hey_celestian)
        options_layout.addLayout(classifier_options)
        
        # Hey-Celestian confidence threshold
        threshold_layout = QHBoxLayout()
        threshold_layout.addWidget(QLabel("Hey-Celestian Confidence Threshold:"))
        self.confidence_threshold = QDoubleSpinBox()
        self.confidence_threshold.setRange(0.0, 1.0)
        self.confidence_threshold.setSingleStep(0.1)
        self.confidence_threshold.setValue(0.5)
        threshold_layout.addWidget(self.confidence_threshold)
        threshold_layout.addStretch()
        options_layout.addLayout(threshold_layout)
        
        right_layout.addWidget(options_group)
        
        # Classification action buttons
        action_layout = QHBoxLayout()
        
        classify_btn = QPushButton("ðŸ” Classify Spectrum")
        classify_btn.clicked.connect(self.classify_current_spectrum)
        classify_btn.setStyleSheet("""
            QPushButton {
                background-color: #1976D2;
                color: white;
                border: none;
                padding: 12px;
                border-radius: 6px;
                font-weight: bold;
                font-size: 12px;
            }
            QPushButton:hover {
                background-color: #1565C0;
            }
        """)
        action_layout.addWidget(classify_btn)
        
        save_results_btn = QPushButton("ðŸ’¾ Save to Database")
        save_results_btn.clicked.connect(self.save_classification_results)
        save_results_btn.setStyleSheet("""
            QPushButton {
                background-color: #388E3C;
                color: white;
                border: none;
                padding: 12px;
                border-radius: 6px;
                font-weight: bold;
                font-size: 12px;
            }
            QPushButton:hover {
                background-color: #2E7D32;
            }
        """)
        action_layout.addWidget(save_results_btn)
        
        action_layout.addStretch()
        right_layout.addLayout(action_layout)
        
        # Results display
        results_group = QGroupBox("Classification Results")
        results_layout = QVBoxLayout(results_group)
        
        self.classification_results_text = QTextEdit()
        self.classification_results_text.setReadOnly(True)
        self.classification_results_text.setFont(QFont("Courier", 10))
        results_layout.addWidget(self.classification_results_text)
        
        right_layout.addWidget(results_group)
        
        splitter.addWidget(right_widget)
        
        # Set splitter proportions
        splitter.setSizes([350, 850])
        splitter.setChildrenCollapsible(False)
        
        self.hey_classification_tabs.addTab(tab, "Single Classification")
        
        # Initialize spectrum list
        self.update_classification_spectrum_list()
    
    def create_batch_classification_tab(self):
        """Create subtab for batch classification processing."""
        tab = QWidget()
        layout = QVBoxLayout(tab)
        
        # Instructions
        info_label = QLabel(
            "Batch classify all spectra in the database using both Traditional Hey and Hey-Celestian systems.\n"
            "This will analyze chemical formulas and apply both classification approaches simultaneously."
        )
        info_label.setWordWrap(True)
        info_label.setStyleSheet("background: #FFF3E0; padding: 10px; border-radius: 5px; margin-bottom: 10px;")
        layout.addWidget(info_label)
        
        # Processing options
        options_group = QGroupBox("Batch Processing Options")
        options_layout = QVBoxLayout(options_group)
        
        # System selection
        systems_layout = QHBoxLayout()
        self.batch_use_traditional = QCheckBox("Process with Traditional Hey Classification")
        self.batch_use_traditional.setChecked(True)
        systems_layout.addWidget(self.batch_use_traditional)
        
        self.batch_use_celestian = QCheckBox("Process with Hey-Celestian Classification")
        self.batch_use_celestian.setChecked(True)  
        systems_layout.addWidget(self.batch_use_celestian)
        options_layout.addLayout(systems_layout)
        
        # Processing settings
        settings_layout = QHBoxLayout()
        settings_layout.addWidget(QLabel("Hey-Celestian Confidence Threshold:"))
        self.batch_confidence_threshold = QDoubleSpinBox()
        self.batch_confidence_threshold.setRange(0.0, 1.0)
        self.batch_confidence_threshold.setSingleStep(0.1)
        self.batch_confidence_threshold.setValue(0.5)
        settings_layout.addWidget(self.batch_confidence_threshold)
        
        self.overwrite_existing = QCheckBox("Overwrite existing classifications")
        settings_layout.addWidget(self.overwrite_existing)
        
        settings_layout.addStretch()
        options_layout.addLayout(settings_layout)
        
        layout.addWidget(options_group)
        
        # Progress and status
        progress_group = QGroupBox("Processing Progress")
        progress_layout = QVBoxLayout(progress_group)
        
        self.batch_classification_progress = QProgressBar()
        progress_layout.addWidget(self.batch_classification_progress)
        
        self.batch_classification_status_label = QLabel("Ready to process batch classification...")
        progress_layout.addWidget(self.batch_classification_status_label)
        
        layout.addWidget(progress_group)
        
        # Action buttons
        button_layout = QHBoxLayout()
        
        start_batch_btn = QPushButton("ðŸš€ Start Batch Classification")
        start_batch_btn.clicked.connect(self.start_batch_classification)
        start_batch_btn.setStyleSheet("""
            QPushButton {
                background-color: #FF9800;
                color: white;
                border: none;
                padding: 15px;
                border-radius: 8px;
                font-weight: bold;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #F57C00;
            }
        """)
        button_layout.addWidget(start_batch_btn)
        
        cancel_batch_btn = QPushButton("âŒ Cancel Processing")
        cancel_batch_btn.clicked.connect(self.cancel_batch_classification)
        button_layout.addWidget(cancel_batch_btn)
        
        button_layout.addStretch()
        layout.addLayout(button_layout)
        
        # Results summary
        summary_group = QGroupBox("Batch Results Summary")
        summary_layout = QVBoxLayout(summary_group)
        
        self.batch_classification_results_text = QTextEdit()
        self.batch_classification_results_text.setReadOnly(True)
        self.batch_classification_results_text.setMaximumHeight(200)
        summary_layout.addWidget(self.batch_classification_results_text)
        
        layout.addWidget(summary_group)
        
        layout.addStretch()
        
        self.hey_classification_tabs.addTab(tab, "Batch Processing")
    
    def create_classification_viewer_tab(self):
        """Create subtab for viewing and managing existing classifications."""
        tab = QWidget()
        layout = QHBoxLayout(tab)
        
        # Create splitter
        splitter = QSplitter(Qt.Horizontal)
        layout.addWidget(splitter)
        
        # Left panel - filter and search
        left_widget = QWidget()
        left_widget.setFixedWidth(350)
        left_layout = QVBoxLayout(left_widget)
        
        # Filter options
        filter_group = QGroupBox("Filter Spectra")
        filter_layout = QVBoxLayout(filter_group)
        
        # Classification status filters
        status_filters = QHBoxLayout()
        self.show_classified = QCheckBox("Show Classified")
        self.show_classified.setChecked(True)
        status_filters.addWidget(self.show_classified)
        
        self.show_unclassified = QCheckBox("Show Unclassified")
        self.show_unclassified.setChecked(True)
        status_filters.addWidget(self.show_unclassified)
        filter_layout.addLayout(status_filters)
        
        # Hey category filter
        category_layout = QHBoxLayout()
        category_layout.addWidget(QLabel("Hey Category:"))
        self.hey_category_filter = QComboBox()
        self.hey_category_filter.addItem("All Categories")
        for category_id, category_name in HEY_CATEGORIES.items():
            self.hey_category_filter.addItem(f"{category_id}: {category_name}")
        category_layout.addWidget(self.hey_category_filter)
        filter_layout.addLayout(category_layout)
        
        # Filter buttons
        filter_buttons = QHBoxLayout()
        apply_filter_btn = QPushButton("Apply Filter")
        apply_filter_btn.clicked.connect(self.apply_classification_filter)
        filter_buttons.addWidget(apply_filter_btn)
        
        clear_filter_btn = QPushButton("Clear Filter")
        clear_filter_btn.clicked.connect(self.clear_classification_filter)
        filter_buttons.addWidget(clear_filter_btn)
        filter_layout.addLayout(filter_buttons)
        
        left_layout.addWidget(filter_group)
        
        # Classification statistics
        stats_group = QGroupBox("Classification Statistics")
        stats_layout = QVBoxLayout(stats_group)
        
        self.classification_stats_text = QTextEdit()
        self.classification_stats_text.setReadOnly(True)
        self.classification_stats_text.setMaximumHeight(200)
        stats_layout.addWidget(self.classification_stats_text)
        
        refresh_stats_btn = QPushButton("Refresh Statistics")
        refresh_stats_btn.clicked.connect(self.update_classification_stats)
        stats_layout.addWidget(refresh_stats_btn)
        
        left_layout.addWidget(stats_group)
        
        splitter.addWidget(left_widget)
        
        # Right panel - spectrum list and details
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        
        # Classified spectra list
        list_group = QGroupBox("Classified Spectra")
        list_layout = QVBoxLayout(list_group)
        
        self.classified_spectra_list = QListWidget()
        self.classified_spectra_list.currentItemChanged.connect(self.on_classified_spectrum_select)
        list_layout.addWidget(self.classified_spectra_list)
        
        right_layout.addWidget(list_group)
        
        # Classification details
        details_group = QGroupBox("Classification Details")
        details_layout = QVBoxLayout(details_group)
        
        self.classification_details_text = QTextEdit()
        self.classification_details_text.setReadOnly(True)
        self.classification_details_text.setFont(QFont("Courier", 10))
        details_layout.addWidget(self.classification_details_text)
        
        # Action buttons for selected spectrum
        detail_buttons = QHBoxLayout()
        
        reclassify_btn = QPushButton("ðŸ”„ Reclassify")
        reclassify_btn.clicked.connect(self.reclassify_selected_spectrum)
        detail_buttons.addWidget(reclassify_btn)
        
        clear_classification_btn = QPushButton("ðŸ—‘ï¸ Clear Classification")
        clear_classification_btn.clicked.connect(self.clear_selected_classification)
        detail_buttons.addWidget(clear_classification_btn)
        
        detail_buttons.addStretch()
        details_layout.addLayout(detail_buttons)
        
        right_layout.addWidget(details_group)
        
        splitter.addWidget(right_widget)
        
        # Set splitter proportions
        splitter.setSizes([350, 850])
        splitter.setChildrenCollapsible(False)
        
        self.hey_classification_tabs.addTab(tab, "Classification Viewer")
        
        # Initialize the viewer
        self.update_classification_stats()
        self.update_classified_spectra_list()
    
    def create_hey_celestian_groups_tab(self):
        """Create subtab for viewing Hey-Celestian classification groups."""
        tab = QWidget()
        layout = QHBoxLayout(tab)
        
        # Create splitter
        splitter = QSplitter(Qt.Horizontal)
        layout.addWidget(splitter)
        
        # Left panel - groups list
        left_widget = QWidget()
        left_widget.setFixedWidth(350)
        left_layout = QVBoxLayout(left_widget)
        
        groups_group = QGroupBox("Hey-Celestian Vibrational Groups")
        groups_layout = QVBoxLayout(groups_group)
        
        self.celestian_groups_list = QListWidget()
        self.celestian_groups_list.currentItemChanged.connect(self.on_celestian_group_select)
        groups_layout.addWidget(self.celestian_groups_list)
        
        left_layout.addWidget(groups_group)
        
        # Add group statistics
        group_stats_group = QGroupBox("Group Statistics")
        group_stats_layout = QVBoxLayout(group_stats_group)
        
        self.group_stats_text = QTextEdit()
        self.group_stats_text.setReadOnly(True)
        self.group_stats_text.setMaximumHeight(150)
        group_stats_layout.addWidget(self.group_stats_text)
        
        left_layout.addWidget(group_stats_group)
        
        splitter.addWidget(left_widget)
        
        # Right panel - group details
        right_widget = QWidget()
        right_layout = QVBoxLayout(right_widget)
        
        # Group information
        info_group = QGroupBox("Group Information")
        info_layout = QVBoxLayout(info_group)
        
        self.group_info_text = QTextEdit()
        self.group_info_text.setReadOnly(True)
        self.group_info_text.setFont(QFont("Arial", 11))
        info_layout.addWidget(self.group_info_text)
        
        right_layout.addWidget(info_group)
        
        # Characteristic modes
        modes_group = QGroupBox("Characteristic Vibrational Modes")
        modes_layout = QVBoxLayout(modes_group)
        
        self.characteristic_modes_text = QTextEdit()
        self.characteristic_modes_text.setReadOnly(True)
        self.characteristic_modes_text.setFont(QFont("Courier", 10))
        modes_layout.addWidget(self.characteristic_modes_text)
        
        right_layout.addWidget(modes_group)
        
        # Analysis strategy
        strategy_group = QGroupBox("Recommended Raman Analysis Strategy")
        strategy_layout = QVBoxLayout(strategy_group)
        
        self.analysis_strategy_text = QTextEdit()
        self.analysis_strategy_text.setReadOnly(True)
        self.analysis_strategy_text.setFont(QFont("Arial", 10))
        strategy_layout.addWidget(self.analysis_strategy_text)
        
        right_layout.addWidget(strategy_group)
        
        splitter.addWidget(right_widget)
        
        # Set splitter proportions  
        splitter.setSizes([350, 850])
        splitter.setChildrenCollapsible(False)
        
        self.hey_classification_tabs.addTab(tab, "Hey-Celestian Groups")
        
        # Initialize the groups list
        self.populate_celestian_groups_list()
    
    # Hey Classification Supporting Methods
    def update_classification_spectrum_list(self):
        """Update the spectrum list for classification."""
        if not hasattr(self, 'classification_spectrum_list'):
            return
            
        self.classification_spectrum_list.clear()
        
        # Get all spectra from database
        search_term = getattr(self, 'classification_search', None)
        search_text = search_term.text().lower() if search_term else ""
        
        for name in sorted(self.raman_db.database.keys()):
            if not search_text or search_text in name.lower():
                item = QListWidgetItem(name)
                item.setData(Qt.UserRole, name)
                self.classification_spectrum_list.addItem(item)
    
    def search_classification_spectra(self):
        """Search spectra for classification."""
        self.update_classification_spectrum_list()
    
    def clear_classification_search(self):
        """Clear classification search."""
        if hasattr(self, 'classification_search'):
            self.classification_search.clear()
            self.update_classification_spectrum_list()
    
    def on_classification_spectrum_select(self, current, previous):
        """Handle spectrum selection for classification."""
        if current is None:
            return
        
        spectrum_name = current.data(Qt.UserRole)
        if not spectrum_name:
            return
        
        self.current_classification_spectrum = self.raman_db.database.get(spectrum_name)
        
        if self.current_classification_spectrum:
            metadata = self.current_classification_spectrum.get('metadata', {})
            
            # Update name display
            mineral_name = metadata.get('mineral_name', '').strip()
            if mineral_name and mineral_name.lower() != 'unknown':
                display_name = mineral_name
            else:
                if '__' in spectrum_name:
                    potential_mineral = spectrum_name.split('__')[0].strip()
                    display_name = potential_mineral if potential_mineral else spectrum_name
                else:
                    display_name = spectrum_name
            
            self.classification_name_label.setText(display_name)
            
            # Try to extract chemical formula from metadata
            self.extract_formula_from_metadata()
            
            # Update current classifications display
            self.update_current_classifications_display()
    
    def extract_formula_from_metadata(self):
        """Extract chemical formula from metadata."""
        if not self.current_classification_spectrum:
            return
        
        metadata = self.current_classification_spectrum.get('metadata', {})
        
        # Debug: Show what metadata keys are available
        print(f"DEBUG: Available metadata keys: {list(metadata.keys())}")
        
        # Look for chemical formula in various metadata fields (expanded list)
        formula_keys = [
            # Primary formula keys (based on your database structure)
            'IDEAL CHEMISTRY', 'MEASURED CHEMISTRY',  # Your database format
            'idealchemistry', 'IDEALCHEMISTRY', 'Ideal_Chemistry', 'ideal_chemistry',
            'measured chemistry', 'MEASURED_CHEMISTRY', 'Measured_Chemistry',
            
            # Standard formula keys
            'chemical_formula', 'formula', 'chemistry', 'mineral_chemistry', 'composition',
            'CHEMICAL_FORMULA', 'FORMULA', 'CHEMISTRY', 'MINERAL_CHEMISTRY', 'COMPOSITION',
            'Chemical_Formula', 'Formula', 'Chemistry', 'Mineral_Chemistry', 'Composition',
            'chemical formula', 'Chemistry Formula', 'Mineral Formula', 'Chemical Composition',
            
            # RRUFF-specific keys
            'RRUFF Chemistry (concise)', 'RRUFF_Chemistry_concise', 'rruff_chemistry',
            'RRUFF Chemistry', 'Chemistry_Elements', 'chemistry_elements'
        ]
        
        formula = ""
        found_key = None
        
        for key in formula_keys:
            if key in metadata and metadata[key]:
                formula = str(metadata[key]).strip()
                found_key = key
                print(f"DEBUG: Found formula '{formula}' in key '{key}'")
                break
        
        if not formula:
            # If no formula found, show available metadata for debugging
            print("DEBUG: No formula found. Available metadata:")
            for key, value in metadata.items():
                print(f"  {key}: {value}")
        
        self.classification_formula_edit.setText(formula)
        
        # Extract elements if formula is available
        if formula:
            try:
                elements = extract_elements_from_formula(formula)
                self.classification_elements_label.setText(", ".join(elements))
                print(f"DEBUG: Extracted elements: {elements}")
            except Exception as e:
                error_msg = f"Error extracting elements: {str(e)}"
                self.classification_elements_label.setText(error_msg)
                print(f"DEBUG: {error_msg}")
        else:
            self.classification_elements_label.setText("No formula available")
            
            # Show a helpful message in the formula field if no formula found
            if metadata:
                self.classification_formula_edit.setPlaceholderText("No formula found in metadata - enter manually")
            else:
                self.classification_formula_edit.setPlaceholderText("No metadata available - enter formula manually")
    
    def update_current_classifications_display(self):
        """Update the display of current classifications."""
        if not self.current_classification_spectrum:
            self.current_classifications_text.clear()
            return
        
        metadata = self.current_classification_spectrum.get('metadata', {})
        
        # Look for existing classifications
        classifications = []
        
        # Traditional Hey classification
        hey_keys = ['hey_classification', 'Hey_Classification', 'HEY_CLASSIFICATION', 'hey_id', 'hey_name']
        for key in hey_keys:
            if key in metadata and metadata[key]:
                classifications.append(f"Traditional Hey: {metadata[key]}")
                break
        
        # Hey-Celestian classification
        celestian_keys = ['hey_celestian_group', 'Hey_Celestian_Group', 'hey_celestian_classification']
        for key in celestian_keys:
            if key in metadata and metadata[key]:
                confidence = metadata.get('hey_celestian_confidence', 'N/A')
                classifications.append(f"Hey-Celestian: {metadata[key]} (Confidence: {confidence})")
                break
        
        if not classifications:
            classifications.append("No classifications found")
        
        self.current_classifications_text.setPlainText("\n".join(classifications))
    
    def classify_current_spectrum(self):
        """Classify the currently selected spectrum."""
        if not self.current_classification_spectrum:
            QMessageBox.warning(self, "No Spectrum", "Please select a spectrum first.")
            return
        
        if not self.hey_classifier and not self.hey_celestian_classifier:
            QMessageBox.warning(self, "No Classifiers", "Classification system not available.")
            return
        
        formula = self.classification_formula_edit.text().strip()
        if not formula:
            QMessageBox.warning(self, "No Formula", "Please enter a chemical formula.")
            return
        
        # Extract elements
        try:
            elements = extract_elements_from_formula(formula)
            elements_str = ", ".join(elements)
        except Exception as e:
            QMessageBox.critical(self, "Formula Error", f"Error parsing formula: {str(e)}")
            return
        
        # Perform classifications
        results = []
        
        # Traditional Hey classification
        if self.use_traditional_hey.isChecked() and self.hey_classifier:
            try:
                hey_result = self.hey_classifier.classify_mineral(formula, elements_str)
                results.append(f"ðŸ”¸ Traditional Hey Classification:")
                results.append(f"   Category ID: {hey_result['id']}")
                results.append(f"   Category: {hey_result['name']}")
                results.append("")
            except Exception as e:
                results.append(f"ðŸ”¸ Traditional Hey Classification: Error - {str(e)}")
                results.append("")
        
        # Hey-Celestian classification
        if self.use_hey_celestian.isChecked() and self.hey_celestian_classifier:
            try:
                spectrum_name = self.classification_name_label.text()
                celestian_result = self.hey_celestian_classifier.classify_mineral(
                    formula, elements_str, spectrum_name
                )
                
                confidence = celestian_result.get('confidence', 0.0)
                threshold = self.confidence_threshold.value()
                
                results.append(f"ðŸ”¹ Hey-Celestian Vibrational Classification:")
                results.append(f"   Best Match: {celestian_result['best_group_name']}")
                results.append(f"   Group ID: {celestian_result['best_group_id']}")
                results.append(f"   Confidence: {confidence:.3f}")
                results.append(f"   Threshold: {threshold:.3f}")
                results.append(f"   Status: {'âœ… High Confidence' if confidence >= threshold else 'âš ï¸ Low Confidence'}")
                results.append(f"   Reasoning: {celestian_result['reasoning']}")
                results.append("")
                
                # Add characteristic vibrational modes
                if hasattr(self.hey_celestian_classifier, 'get_characteristic_modes_for_group'):
                    modes = self.hey_celestian_classifier.get_characteristic_modes_for_group(celestian_result['best_group_id'])
                    if modes:
                        results.append("   Expected Vibrational Modes:")
                        for mode in modes[:3]:  # Show top 3 modes
                            results.append(f"     â€¢ {mode['description']}: {mode['peak']} cmâ»Â¹ ({mode['range'][0]}-{mode['range'][1]} cmâ»Â¹)")
                        results.append("")
                
            except Exception as e:
                results.append(f"ðŸ”¹ Hey-Celestian Classification: Error - {str(e)}")
                results.append("")
        
        # Display results
        if results:
            self.classification_results_text.setPlainText("\n".join(results))
        else:
            self.classification_results_text.setPlainText("No classification methods selected.")
    
    def save_classification_results(self):
        """Save classification results to database."""
        if not self.current_classification_spectrum:
            QMessageBox.warning(self, "No Spectrum", "Please select a spectrum first.")
            return
        
        # Get spectrum name
        current_item = self.classification_spectrum_list.currentItem()
        if not current_item:
            return
        
        spectrum_name = current_item.data(Qt.UserRole)
        formula = self.classification_formula_edit.text().strip()
        
        if not formula:
            QMessageBox.warning(self, "No Formula", "Please enter a chemical formula first.")
            return
        
        try:
            elements = extract_elements_from_formula(formula)
            elements_str = ", ".join(elements)
        except Exception as e:
            QMessageBox.critical(self, "Formula Error", f"Error parsing formula: {str(e)}")
            return
        
        # Perform classifications and save to metadata
        metadata = self.current_classification_spectrum.get('metadata', {})
        saved_classifications = []
        
        # Traditional Hey classification
        if self.use_traditional_hey.isChecked() and self.hey_classifier:
            try:
                hey_result = self.hey_classifier.classify_mineral(formula, elements_str)
                metadata['hey_classification_id'] = hey_result['id']
                metadata['hey_classification_name'] = hey_result['name']
                metadata['hey_classification_formula'] = formula
                saved_classifications.append(f"Traditional Hey: {hey_result['name']}")
            except Exception as e:
                QMessageBox.warning(self, "Classification Error", f"Traditional Hey classification failed: {str(e)}")
        
        # Hey-Celestian classification
        if self.use_hey_celestian.isChecked() and self.hey_celestian_classifier:
            try:
                spectrum_name_for_classification = self.classification_name_label.text()
                celestian_result = self.hey_celestian_classifier.classify_mineral(
                    formula, elements_str, spectrum_name_for_classification
                )
                
                metadata['hey_celestian_group_id'] = celestian_result['best_group_id']
                metadata['hey_celestian_group_name'] = celestian_result['best_group_name']
                metadata['hey_celestian_confidence'] = celestian_result['confidence']
                metadata['hey_celestian_reasoning'] = celestian_result['reasoning']
                metadata['hey_celestian_formula'] = formula
                
                saved_classifications.append(f"Hey-Celestian: {celestian_result['best_group_name']} ({celestian_result['confidence']:.3f})")
            except Exception as e:
                QMessageBox.warning(self, "Classification Error", f"Hey-Celestian classification failed: {str(e)}")
        
        if saved_classifications:
            # Update the database
            self.raman_db.database[spectrum_name]['metadata'] = metadata
            
            # Save to database
            try:
                self.raman_db.save_database()
                
                # Update displays
                self.update_current_classifications_display()
                self.update_classification_stats()
                
                QMessageBox.information(
                    self,
                    "Success",
                    f"Saved classifications for '{spectrum_name}':\n" + "\n".join(saved_classifications)
                )
                
            except Exception as e:
                QMessageBox.critical(self, "Save Error", f"Failed to save to database: {str(e)}")
        else:
            QMessageBox.warning(self, "No Results", "No classifications were generated to save.")
    
    def start_batch_classification(self):
        """Start batch classification of all spectra."""
        if not self.hey_classifier and not self.hey_celestian_classifier:
            QMessageBox.warning(self, "No Classifiers", "Classification system not available.")
            return
        
        if not self.batch_use_traditional.isChecked() and not self.batch_use_celestian.isChecked():
            QMessageBox.warning(self, "No Methods", "Please select at least one classification method.")
            return
        
        # Confirm batch processing
        total_spectra = len(self.raman_db.database)
        reply = QMessageBox.question(
            self,
            "Confirm Batch Processing",
            f"This will process {total_spectra} spectra with the selected classification methods.\n\n"
            f"Traditional Hey: {'âœ… Enabled' if self.batch_use_traditional.isChecked() else 'âŒ Disabled'}\n"
            f"Hey-Celestian: {'âœ… Enabled' if self.batch_use_celestian.isChecked() else 'âŒ Disabled'}\n\n"
            f"Continue?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply != QMessageBox.Yes:
            return
        
        # Process batch
        self.batch_classification_progress.setMaximum(total_spectra)
        self.batch_classification_progress.setValue(0)
        
        processed = 0
        hey_success = 0
        celestian_success = 0
        errors = 0
        
        for spectrum_name, spectrum_data in self.raman_db.database.items():
            self.batch_classification_status_label.setText(f"Processing: {spectrum_name}")
            QApplication.processEvents()
            
            metadata = spectrum_data.get('metadata', {})
            
            # Skip if not overwriting and classifications exist
            if not self.overwrite_existing.isChecked():
                has_hey = any(key in metadata for key in ['hey_classification_id', 'hey_classification_name'])
                has_celestian = any(key in metadata for key in ['hey_celestian_group_id', 'hey_celestian_group_name'])
                
                if has_hey and has_celestian:
                    processed += 1
                    self.batch_classification_progress.setValue(processed)
                    continue
            
#            Try to extract formula from metadata
             formula_keys = [
                 # Primary formula keys (based on your database structure)
                 'IDEAL CHEMISTRY', 'MEASURED CHEMISTRY',
                 'idealchemistry', 'IDEALCHEMISTRY', 'Ideal_Chemistry', 'ideal_chemistry',
                 'measured chemistry', 'MEASURED_CHEMISTRY', 'Measured_Chemistry',
                 # Standard formula keys
                 'chemical_formula', 'formula', 'chemistry', 'mineral_chemistry', 'composition',
                 'CHEMICAL_FORMULA', 'FORMULA', 'CHEMISTRY', 'MINERAL_CHEMISTRY', 'COMPOSITION'
             ]
             formula = ""
             
             for key in formula_keys:
                 if key in metadata and metadata[key]:
                     formula = str(metadata[key]).strip()
                     break
            
            if not formula:
                errors += 1
                processed += 1
                self.batch_classification_progress.setValue(processed)
                continue
            
            try:
                elements = extract_elements_from_formula(formula)
                elements_str = ", ".join(elements)
                
                # Traditional Hey classification
                if self.batch_use_traditional.isChecked() and self.hey_classifier:
                    try:
                        hey_result = self.hey_classifier.classify_mineral(formula, elements_str)
                        metadata['hey_classification_id'] = hey_result['id']
                        metadata['hey_classification_name'] = hey_result['name']
                        metadata['hey_classification_formula'] = formula
                        hey_success += 1
                    except Exception:
                        pass
                
                # Hey-Celestian classification  
                if self.batch_use_celestian.isChecked() and self.hey_celestian_classifier:
                    try:
                        # Extract mineral name for classification
                        mineral_name = metadata.get('mineral_name', spectrum_name)
                        celestian_result = self.hey_celestian_classifier.classify_mineral(
                            formula, elements_str, mineral_name
                        )
                        
                        if celestian_result['confidence'] >= self.batch_confidence_threshold.value():
                            metadata['hey_celestian_group_id'] = celestian_result['best_group_id']
                            metadata['hey_celestian_group_name'] = celestian_result['best_group_name']
                            metadata['hey_celestian_confidence'] = celestian_result['confidence']
                            metadata['hey_celestian_reasoning'] = celestian_result['reasoning']
                            metadata['hey_celestian_formula'] = formula
                            celestian_success += 1
                    except Exception:
                        pass
                
                # Update metadata
                spectrum_data['metadata'] = metadata
                
            except Exception:
                errors += 1
            
            processed += 1
            self.batch_classification_progress.setValue(processed)
        
        # Save database
        try:
            self.raman_db.save_database()
            
            # Update displays
            self.update_classification_stats()
            self.update_classified_spectra_list()
            
            # Show results
            results_text = f"Batch Classification Complete!\n\n"
            results_text += f"ðŸ“Š Processing Summary:\n"
            results_text += f"   Total Spectra: {total_spectra}\n"
            results_text += f"   Processed: {processed}\n\n"
            results_text += f"ðŸ”¸ Traditional Hey Classifications: {hey_success}\n"
            results_text += f"ðŸ”¹ Hey-Celestian Classifications: {celestian_success}\n"
            results_text += f"âŒ Errors/Skipped: {errors}\n\n"
            results_text += f"Database updated successfully!"
            
            self.batch_classification_results_text.setPlainText(results_text)
            self.batch_classification_status_label.setText("Batch classification completed!")
            
            QMessageBox.information(self, "Batch Complete", results_text)
            
        except Exception as e:
            QMessageBox.critical(self, "Save Error", f"Failed to save database: {str(e)}")
    
    def cancel_batch_classification(self):
        """Cancel batch classification."""
        # Implementation for canceling would go here
        self.batch_classification_status_label.setText("Batch classification cancelled.")
    
    def update_classification_stats(self):
        """Update classification statistics."""
        if not hasattr(self, 'classification_stats_text'):
            return
            
        total_spectra = len(self.raman_db.database)
        hey_classified = 0
        celestian_classified = 0
        both_classified = 0
        
        hey_categories = {}
        celestian_groups = {}
        
        for spectrum_name, spectrum_data in self.raman_db.database.items():
            metadata = spectrum_data.get('metadata', {})
            
            has_hey = any(key in metadata for key in ['hey_classification_id', 'hey_classification_name'])
            has_celestian = any(key in metadata for key in ['hey_celestian_group_id', 'hey_celestian_group_name'])
            
            if has_hey:
                hey_classified += 1
                hey_name = metadata.get('hey_classification_name', 'Unknown')
                hey_categories[hey_name] = hey_categories.get(hey_name, 0) + 1
            
            if has_celestian:
                celestian_classified += 1
                celestian_name = metadata.get('hey_celestian_group_name', 'Unknown')
                celestian_groups[celestian_name] = celestian_groups.get(celestian_name, 0) + 1
            
            if has_hey and has_celestian:
                both_classified += 1
        
        stats_text = f"Classification Statistics:\n\n"
        stats_text += f"ðŸ“Š Overview:\n"
        stats_text += f"   Total Spectra: {total_spectra}\n"
        stats_text += f"   Hey Classified: {hey_classified} ({hey_classified/total_spectra*100:.1f}%)\n"
        stats_text += f"   Celestian Classified: {celestian_classified} ({celestian_classified/total_spectra*100:.1f}%)\n"
        stats_text += f"   Both Classified: {both_classified} ({both_classified/total_spectra*100:.1f}%)\n\n"
        
        if hey_categories:
            stats_text += f"ðŸ”¸ Top Hey Categories:\n"
            for category, count in sorted(hey_categories.items(), key=lambda x: x[1], reverse=True)[:5]:
                stats_text += f"   {category}: {count}\n"
            stats_text += "\n"
        
        if celestian_groups:
            stats_text += f"ðŸ”¹ Top Celestian Groups:\n"
            for group, count in sorted(celestian_groups.items(), key=lambda x: x[1], reverse=True)[:5]:
                stats_text += f"   {group}: {count}\n"
        
        self.classification_stats_text.setPlainText(stats_text)
    
    def update_classified_spectra_list(self):
        """Update the list of classified spectra."""
        if not hasattr(self, 'classified_spectra_list'):
            return
            
        self.classified_spectra_list.clear()
        
        for spectrum_name, spectrum_data in sorted(self.raman_db.database.items()):
            metadata = spectrum_data.get('metadata', {})
            
            has_hey = any(key in metadata for key in ['hey_classification_id', 'hey_classification_name'])
            has_celestian = any(key in metadata for key in ['hey_celestian_group_id', 'hey_celestian_group_name'])
            
            show_spectrum = False
            if self.show_classified.isChecked() and (has_hey or has_celestian):
                show_spectrum = True
            if self.show_unclassified.isChecked() and not (has_hey or has_celestian):
                show_spectrum = True
            
            if show_spectrum:
                # Create display text
                status_icons = []
                if has_hey:
                    status_icons.append("ðŸ”¸")
                if has_celestian:
                    status_icons.append("ðŸ”¹")
                if not status_icons:
                    status_icons.append("âŒ")
                
                display_text = f"{''.join(status_icons)} {spectrum_name}"
                
                item = QListWidgetItem(display_text)
                item.setData(Qt.UserRole, spectrum_name)
                self.classified_spectra_list.addItem(item)
    
    def apply_classification_filter(self):
        """Apply classification filter."""
        self.update_classified_spectra_list()
    
    def clear_classification_filter(self):
        """Clear classification filter."""
        self.show_classified.setChecked(True)
        self.show_unclassified.setChecked(True)
        self.hey_category_filter.setCurrentIndex(0)
        self.update_classified_spectra_list()
    
    def on_classified_spectrum_select(self, current, previous):
        """Handle classified spectrum selection."""
        if current is None:
            return
        
        spectrum_name = current.data(Qt.UserRole)
        if not spectrum_name:
            return
        
        spectrum_data = self.raman_db.database.get(spectrum_name)
        if not spectrum_data:
            return
        
        metadata = spectrum_data.get('metadata', {})
        
        # Display classification details
        details = f"Classification Details for: {spectrum_name}\n"
        details += "=" * 60 + "\n\n"
        
        # Traditional Hey classification
        if any(key in metadata for key in ['hey_classification_id', 'hey_classification_name']):
            details += "ðŸ”¸ Traditional Hey Classification:\n"
            details += f"   ID: {metadata.get('hey_classification_id', 'N/A')}\n"
            details += f"   Name: {metadata.get('hey_classification_name', 'N/A')}\n"
            details += f"   Formula: {metadata.get('hey_classification_formula', 'N/A')}\n\n"
        else:
            details += "ðŸ”¸ Traditional Hey Classification: Not assigned\n\n"
        
        # Hey-Celestian classification
        if any(key in metadata for key in ['hey_celestian_group_id', 'hey_celestian_group_name']):
            details += "ðŸ”¹ Hey-Celestian Vibrational Classification:\n"
            details += f"   Group ID: {metadata.get('hey_celestian_group_id', 'N/A')}\n"
            details += f"   Group Name: {metadata.get('hey_celestian_group_name', 'N/A')}\n"
            details += f"   Confidence: {metadata.get('hey_celestian_confidence', 'N/A')}\n"
            details += f"   Reasoning: {metadata.get('hey_celestian_reasoning', 'N/A')}\n"
            details += f"   Formula: {metadata.get('hey_celestian_formula', 'N/A')}\n\n"
        else:
            details += "ðŸ”¹ Hey-Celestian Classification: Not assigned\n\n"
        
        # Additional metadata
        details += "ðŸ“‹ Additional Metadata:\n"
        for key, value in metadata.items():
            if not key.startswith(('hey_', 'Hey_')):
                details += f"   {key}: {value}\n"
        
        self.classification_details_text.setPlainText(details)
    
    def reclassify_selected_spectrum(self):
        """Reclassify the selected spectrum."""
        current_item = self.classified_spectra_list.currentItem()
        if not current_item:
            QMessageBox.warning(self, "No Selection", "Please select a spectrum first.")
            return
        
        spectrum_name = current_item.data(Qt.UserRole)
        
        # Switch to single classification tab and load this spectrum
        self.hey_classification_tabs.setCurrentIndex(0)  # Single Classification tab
        
        # Find and select the spectrum in the classification list
        for i in range(self.classification_spectrum_list.count()):
            item = self.classification_spectrum_list.item(i)
            if item.data(Qt.UserRole) == spectrum_name:
                self.classification_spectrum_list.setCurrentItem(item)
                break
    
    def clear_selected_classification(self):
        """Clear classification for selected spectrum."""
        current_item = self.classified_spectra_list.currentItem()
        if not current_item:
            QMessageBox.warning(self, "No Selection", "Please select a spectrum first.")
            return
        
        spectrum_name = current_item.data(Qt.UserRole)
        
        reply = QMessageBox.question(
            self,
            "Clear Classifications",
            f"Remove all classifications for '{spectrum_name}'?\n\nThis cannot be undone.",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            spectrum_data = self.raman_db.database.get(spectrum_name)
            if spectrum_data:
                metadata = spectrum_data.get('metadata', {})
                
                # Remove classification keys
                keys_to_remove = [
                    'hey_classification_id', 'hey_classification_name', 'hey_classification_formula',
                    'hey_celestian_group_id', 'hey_celestian_group_name', 'hey_celestian_confidence',
                    'hey_celestian_reasoning', 'hey_celestian_formula'
                ]
                
                for key in keys_to_remove:
                    metadata.pop(key, None)
                
                spectrum_data['metadata'] = metadata
                
                # Save database
                try:
                    self.raman_db.save_database()
                    
                    # Update displays
                    self.update_classification_stats()
                    self.update_classified_spectra_list()
                    self.classification_details_text.clear()
                    
                    QMessageBox.information(self, "Success", f"Classifications cleared for '{spectrum_name}'!")
                    
                except Exception as e:
                    QMessageBox.critical(self, "Save Error", f"Failed to save changes: {str(e)}")
    
    def populate_celestian_groups_list(self):
        """Populate the Hey-Celestian groups list."""
        if not hasattr(self, 'celestian_groups_list') or not self.hey_celestian_classifier:
            return
        
        self.celestian_groups_list.clear()
        
        # Get vibrational groups from the classifier
        groups = self.hey_celestian_classifier.vibrational_groups
        
        for group_id, group_info in groups.items():
            display_text = f"{group_id}: {group_info['name']}"
            item = QListWidgetItem(display_text)
            item.setData(Qt.UserRole, group_id)
            self.celestian_groups_list.addItem(item)
    
    def on_celestian_group_select(self, current, previous):
        """Handle Hey-Celestian group selection."""
        if current is None or not self.hey_celestian_classifier:
            return
        
        group_id = current.data(Qt.UserRole)
        if not group_id:
            return
        
        # Get group information
        group_info = self.hey_celestian_classifier.get_classification_info(group_id)
        if not group_info:
            return
        
        # Display group information
        info_text = f"{group_info['name']}\n"
        info_text += "=" * len(group_info['name']) + "\n\n"
        info_text += f"Description: {group_info['description']}\n\n"
        info_text += f"Typical Wavenumber Range: {group_info['typical_range']}\n\n"
        info_text += "Example Minerals:\n"
        for example in group_info['examples']:
            info_text += f"  â€¢ {example}\n"
        
        self.group_info_text.setPlainText(info_text)
        
        # Display characteristic modes
        modes = self.hey_celestian_classifier.get_characteristic_modes_for_group(group_id)
        if modes:
            modes_text = "Characteristic Vibrational Modes:\n\n"
            for mode in modes:
                modes_text += f"Mode: {mode['description']}\n"
                modes_text += f"  Peak Position: {mode['peak']} cmâ»Â¹\n"
                modes_text += f"  Range: {mode['range'][0]} - {mode['range'][1]} cmâ»Â¹\n\n"
        else:
            modes_text = "No specific characteristic modes defined for this group."
        
        self.characteristic_modes_text.setPlainText(modes_text)
        
        # Display analysis strategy
        strategy = self.hey_celestian_classifier.suggest_raman_analysis_strategy(group_id)
        if strategy:
            strategy_text = f"Recommended Raman Analysis Strategy:\n\n"
            strategy_text += f"Focus Regions: {strategy.get('focus_regions', 'Not specified')}\n\n"
            strategy_text += f"Key Peaks to Look For: {strategy.get('key_peaks', 'Not specified')}\n\n"
            strategy_text += f"Analysis Tips: {strategy.get('analysis_tips', 'Not specified')}\n\n"
            strategy_text += f"Common Interferences: {strategy.get('interferences', 'Not specified')}\n"
        else:
            strategy_text = "No specific analysis strategy available for this group."
        
        self.analysis_strategy_text.setPlainText(strategy_text)
        
        # Update group statistics
        self.update_group_statistics(group_id, group_info['name'])
    
    def update_group_statistics(self, group_id, group_name):
        """Update statistics for the selected group."""
        if not hasattr(self, 'group_stats_text'):
            return
        
        # Count spectra in this group
        group_count = 0
        total_classified = 0
        
        for spectrum_name, spectrum_data in self.raman_db.database.items():
            metadata = spectrum_data.get('metadata', {})
            
            if metadata.get('hey_celestian_group_id') == group_id:
                group_count += 1
            
            if any(key in metadata for key in ['hey_celestian_group_id', 'hey_celestian_group_name']):
                total_classified += 1
        
        stats_text = f"Group Statistics:\n\n"
        stats_text += f"Group: {group_name}\n"
        stats_text += f"Spectra in Group: {group_count}\n"
        stats_text += f"Total Classified: {total_classified}\n"
        stats_text += f"Percentage: {group_count/total_classified*100:.1f}%" if total_classified > 0 else "Percentage: 0%"
        
        self.group_stats_text.setPlainText(stats_text)
    
    def show_metadata_debug(self):
        """Show metadata debug information for the current spectrum."""
        if not self.current_classification_spectrum:
            QMessageBox.warning(self, "No Spectrum", "Please select a spectrum first.")
            return
        
        # Get spectrum name
        current_item = self.classification_spectrum_list.currentItem()
        spectrum_name = current_item.data(Qt.UserRole) if current_item else "Unknown"
        
        metadata = self.current_classification_spectrum.get('metadata', {})
        
        # Create debug dialog
        dialog = QDialog(self)
        dialog.setWindowTitle(f"Metadata Debug - {spectrum_name}")
        dialog.setMinimumSize(700, 500)
        
        layout = QVBoxLayout(dialog)
        
        # Instructions
        info_label = QLabel(
            "This shows all metadata keys and values for the selected spectrum.\n"
            "Look for keys that might contain chemical formulas or composition data."
        )
        info_label.setWordWrap(True)
        info_label.setStyleSheet("background: #E3F2FD; padding: 10px; border-radius: 5px; margin-bottom: 10px;")
        layout.addWidget(info_label)
        
        # Metadata display
        metadata_text = QTextEdit()
        metadata_text.setReadOnly(True)
        metadata_text.setFont(QFont("Courier", 10))
        
        if metadata:
            debug_content = f"Metadata for: {spectrum_name}\n"
            debug_content += "=" * 60 + "\n\n"
            debug_content += f"Total metadata keys: {len(metadata)}\n\n"
            
            # Group metadata by potential relevance
            formula_related = []
            classification_related = []
            other_metadata = []
            
            for key, value in metadata.items():
                key_lower = key.lower()
                if any(term in key_lower for term in ['formula', 'chemistry', 'composition', 'element']):
                    formula_related.append((key, value))
                elif any(term in key_lower for term in ['classification', 'hey', 'celestian', 'group']):
                    classification_related.append((key, value))
                else:
                    other_metadata.append((key, value))
            
            if formula_related:
                debug_content += "ðŸ§ª FORMULA/CHEMISTRY RELATED METADATA:\n"
                debug_content += "-" * 40 + "\n"
                for key, value in formula_related:
                    debug_content += f"  {key}: {value}\n"
                debug_content += "\n"
            
            if classification_related:
                debug_content += "ðŸ”¬ CLASSIFICATION RELATED METADATA:\n"
                debug_content += "-" * 40 + "\n"
                for key, value in classification_related:
                    debug_content += f"  {key}: {value}\n"
                debug_content += "\n"
            
            if other_metadata:
                debug_content += "ðŸ“‹ OTHER METADATA:\n"
                debug_content += "-" * 40 + "\n"
                for key, value in other_metadata:
                    debug_content += f"  {key}: {value}\n"
                debug_content += "\n"
            
            # Add suggestion
            if formula_related:
                debug_content += "ðŸ’¡ SUGGESTIONS:\n"
                debug_content += "-" * 40 + "\n"
                debug_content += "Found formula-related metadata! The system should automatically\n"
                debug_content += "extract formulas from these fields. If it's not working, the keys\n"
                debug_content += "might need to be added to the formula_keys list in the code.\n\n"
                debug_content += "You can manually copy the formula from above and paste it into\n"
                debug_content += "the Chemical Formula field in the classification interface.\n"
            else:
                debug_content += "âš ï¸  NO FORMULA METADATA FOUND:\n"
                debug_content += "-" * 40 + "\n"
                debug_content += "No chemistry/formula metadata detected. You'll need to:\n"
                debug_content += "1. Manually enter the chemical formula, OR\n"
                debug_content += "2. Add formula metadata to your spectra, OR\n"
                debug_content += "3. Check if the formula is stored under a different key name\n"
                
        else:
            debug_content = f"No metadata found for: {spectrum_name}\n\n"
            debug_content += "This spectrum has no metadata attached. To use the classification\n"
            debug_content += "system, you'll need to manually enter the chemical formula.\n\n"
            debug_content += "Consider adding metadata to your spectra using the metadata editor\n"
            debug_content += "in the main database browser tab."
        
        metadata_text.setPlainText(debug_content)
        layout.addWidget(metadata_text)
        
        # Close button
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dialog.close)
        layout.addWidget(close_btn)
        
        dialog.exec()
        

class MetadataEditorDialog(QDialog):
    """Dialog for editing spectrum metadata."""
    
    def __init__(self, metadata, spectrum_name, parent=None):
        super().__init__(parent)
        self.metadata = metadata.copy()
        self.spectrum_name = spectrum_name
        self.field_widgets = {}  # Store references to input widgets
        
        self.setWindowTitle(f"Edit Metadata - {spectrum_name}")
        self.setMinimumSize(600, 500)
        self.resize(700, 600)
        
        self.setup_ui()
        self.populate_fields()
    
    def setup_ui(self):
        """Set up the user interface."""
        layout = QVBoxLayout(self)
        layout.setAlignment(Qt.AlignTop | Qt.AlignLeft)  # Left-justify content
        
        # Title
        title = QLabel(f"Editing metadata for: {self.spectrum_name}")
        title.setFont(QFont("Arial", 12, QFont.Bold))
        title.setAlignment(Qt.AlignLeft)  # Left-align title
        layout.addWidget(title)
        
        # Create scrollable area for metadata fields
        from PySide6.QtWidgets import QScrollArea
        scroll_area = QScrollArea()
        scroll_widget = QWidget()
        self.fields_layout = QFormLayout(scroll_widget)
        
        # Configure form layout for left-justified, wider fields
        self.fields_layout.setLabelAlignment(Qt.AlignLeft)
        self.fields_layout.setFormAlignment(Qt.AlignLeft | Qt.AlignTop)
        self.fields_layout.setFieldGrowthPolicy(QFormLayout.ExpandingFieldsGrow)
        
        # Set the label-to-field ratio (25% labels, 75% fields)
        self.fields_layout.setRowWrapPolicy(QFormLayout.DontWrapRows)
        
        scroll_area.setWidget(scroll_widget)
        scroll_area.setWidgetResizable(True)
        scroll_area.setMinimumHeight(350)
        layout.addWidget(scroll_area)
        
        # Add new field section
        new_field_group = QGroupBox("Add New Field")
        new_field_layout = QHBoxLayout(new_field_group)
        
        new_field_layout.addWidget(QLabel("Field Name:"))
        self.new_field_name = QLineEdit()
        self.new_field_name.setPlaceholderText("Enter field name...")
        new_field_layout.addWidget(self.new_field_name)
        
        new_field_layout.addWidget(QLabel("Value:"))
        self.new_field_value = QLineEdit()
        self.new_field_value.setPlaceholderText("Enter field value...")
        new_field_layout.addWidget(self.new_field_value)
        
        add_field_btn = QPushButton("Add Field")
        add_field_btn.clicked.connect(self.add_new_field)
        new_field_layout.addWidget(add_field_btn)
        
        layout.addWidget(new_field_group)
        
        # Instructions
        instructions = QLabel(
            "â€¢ Edit existing fields directly in the form above\n"
            "â€¢ Use 'Add New Field' to add custom metadata\n"
            "â€¢ Clear field contents to effectively remove them\n"
            "â€¢ Click 'Save Changes' to update the database"
        )
        instructions.setStyleSheet("color: #666; font-size: 10px; padding: 10px;")
        instructions.setAlignment(Qt.AlignLeft)  # Left-align instructions
        layout.addWidget(instructions)
        
        # Buttons
        button_layout = QHBoxLayout()
        
        save_btn = QPushButton("Save Changes")
        save_btn.clicked.connect(self.accept)
        save_btn.setDefault(True)
        button_layout.addWidget(save_btn)
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        button_layout.addWidget(cancel_btn)
        
        reset_btn = QPushButton("Reset to Original")
        reset_btn.clicked.connect(self.reset_fields)
        button_layout.addWidget(reset_btn)
        
        button_layout.addStretch()
        layout.addLayout(button_layout)
    
    def populate_fields(self):
        """Populate the form with existing metadata fields."""
        # Define common fields with better labels and order
        common_fields = [
            ('mineral_name', 'Mineral Name'),
            ('description', 'Description'),
            ('laser_wavelength', 'Laser Wavelength'),
            ('source_file', 'Source File'),
            ('timestamp', 'Timestamp'),
            ('sample_id', 'Sample ID'),
            ('location', 'Location/Origin'),
            ('operator', 'Operator'),
            ('instrument', 'Instrument'),
            ('acquisition_time', 'Acquisition Time'),
            ('laser_power', 'Laser Power'),
            ('integration_time', 'Integration Time'),
            ('temperature', 'Temperature'),
            ('pressure', 'Pressure'),
            ('notes', 'Additional Notes')
        ]
        
        # Add common fields first (whether they exist or not)
        for field_key, field_label in common_fields:
            value = self.metadata.get(field_key, '')
            self.add_field_widget(field_key, field_label, value)
        
        # Add any additional custom fields that aren't in the common list
        common_keys = [key for key, _ in common_fields]
        for key, value in self.metadata.items():
            if key not in common_keys:
                # Format the key for display
                display_label = key.replace('_', ' ').title()
                self.add_field_widget(key, display_label, str(value))
    
    def add_field_widget(self, field_key, field_label, value):
        """Add a field widget to the form."""
        if field_key == 'description' or field_key == 'notes':
            # Use QTextEdit for longer text fields
            widget = QTextEdit()
            widget.setMaximumHeight(80)
            widget.setPlainText(str(value))
            widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        else:
            # Use QLineEdit for single-line fields
            widget = QLineEdit()
            widget.setText(str(value))
            widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
            if field_key == 'timestamp':
                widget.setReadOnly(True)  # Timestamps shouldn't be manually edited
                widget.setStyleSheet("background-color: #f0f0f0;")
        
        # Set minimum width to ensure fields take up sufficient space
        widget.setMinimumWidth(300)
        
        # Add the widget directly to the form layout (no delete buttons)
        self.fields_layout.addRow(field_label + ":", widget)
        self.field_widgets[field_key] = widget
    
    def add_new_field(self):
        """Add a new metadata field."""
        field_name = self.new_field_name.text().strip()
        field_value = self.new_field_value.text().strip()
        
        if not field_name:
            QMessageBox.warning(self, "Invalid Field", "Please enter a field name.")
            return
        
        # Convert field name to a valid key
        field_key = field_name.lower().replace(' ', '_').replace('-', '_')
        
        # Check if field already exists
        if field_key in self.field_widgets:
            QMessageBox.warning(self, "Field Exists", f"Field '{field_name}' already exists.")
            return
        
        # Add the field
        self.add_field_widget(field_key, field_name, field_value)
        
        # Clear the input fields
        self.new_field_name.clear()
        self.new_field_value.clear()
    
    def reset_fields(self):
        """Reset all fields to their original values."""
        reply = QMessageBox.question(
            self,
            "Reset Fields",
            "Are you sure you want to reset all fields to their original values?\n\nThis will lose any unsaved changes.",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            # Clear existing fields
            self.field_widgets.clear()
            
            # Clear the form layout
            while self.fields_layout.rowCount() > 0:
                self.fields_layout.removeRow(0)
            
            # Repopulate with original values
            self.populate_fields()
    
    def get_metadata(self):
        """Get the current metadata from the form fields."""
        updated_metadata = {}
        
        for field_key, widget in self.field_widgets.items():
            if isinstance(widget, QTextEdit):
                value = widget.toPlainText().strip()
            else:
                value = widget.text().strip()
            
            # Only include non-empty values
            if value:
                updated_metadata[field_key] = value
        
        return updated_metadata
        